{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"A jegyzetr\u0151l","text":"<ul> <li>Ha hib\u00e1t tal\u00e1lsz a jegyzetben, azt k\u00e9rlek jelezd a https://github.com/nevemlaci/prog2_jegyzet/issues oldalon.</li> <li>Ha a jegyzetb\u0151l haszn\u00e1lsz k\u00f3dr\u00e9szletet, kommentben jelezd, hogy innen van. (f\u0151leg h\u00e1ziban, pl\u00e1gium elker\u00fcl\u00e9se v\u00e9gett!)</li> </ul> <p>FONTOS! A C++ nyelv a n\u00e9pszer\u0171 nyelvek k\u00f6z\u00f6tt az egyik legnehezebb, elsaj\u00e1t\u00edt\u00e1sa megfelel\u0151 figyelmet \u00e9s er\u0151befektet\u00e9st ig\u00e9nyel. A jegyzetben minden sornak jelent\u00e9se van, azokban potenci\u00e1lisan olyan inform\u00e1ci\u00f3 rejlik, amely k\u00e9s\u0151bb kritikus tud\u00e1sk\u00e9nt szolg\u00e1lhat. \u00c9rdemes minden sort elolvasni \u00e9s \u00e9rtelmezni a k\u00f3dr\u00e9szleteket. A programoz\u00e1s t\u00e9nyleges megtanul\u00e1s\u00e1hoz elengedhetetlen, hogy hallgat\u00f3k\u00e9nt a programoz\u00e1sra hobbik\u00e9nt is tekints\u00fcnk.</p> <p>A jegyzet A Programoz\u00e1s Alapjai 2 c\u00edm\u0171 t\u00e1rgyhoz k\u00e9sz\u00fclt, viszont egyes esetekben kit\u00e9r\u0151ket tesz, hogy az esetleges C++ nyelv ir\u00e1nt \u00e9rdekl\u0151d\u0151 hallgat\u00f3kat elm\u00e9ly\u00edtse a nyelv sz\u00e9ps\u00e9geiben.</p> <p>A jegyzetben pr\u00f3b\u00e1ltam a tananyag menet\u00e9hez alkalmazkodni, csak akkor v\u00e1ltoztattam, amikor a tananyagban esetleg \u00e9rdemesebbnek l\u00e1ttam egyes fogalmakat hamarabb bevezetni.</p> <p>A legt\u00f6bb anyaghoz tal\u00e1lhat\u00f3ak k\u00fcls\u0151 linkek hasznos oldalakhoz, azonban egyesek(pl. cppreference) kicsit b\u0151vebben elmagyar\u00e1znak egyes aspektusokat, mint ami a t\u00e1rgyhoz sz\u00fcks\u00e9ges.</p> <p>Ezen fel\u00fcl fontos azt megjegyezni, hogy a t\u00e1rgy C++ verzi\u00f3ban inkonzisztens(pl. egyes ellen\u0151rz\u0151 feladatok C++03-ra vannak \u00e1ll\u00edtva), n\u00e9h\u00e1ny laboron m\u0171k\u00f6dni fog az, ami a m\u00e1sikon nem. Viszont a h\u00e1zi feladatban elvileg C++17 verzi\u00f3val fordul minden. A laborokon elvileg lehet (\u00e9s Windowson ezt aj\u00e1nlom!) Visual Studioban dolgozni, ami viszont C++14-n\u00e9l r\u00e9gebbi verzi\u00f3kat nem t\u00e1mogat. </p>"},{"location":"#compiler-explorer-godbolt","title":"Compiler Explorer (Godbolt)","text":"<p>A Compiler Explorer egy weboldal, ahol mindenf\u00e9le nyelven \u00edrt programok k\u00fcl\u00f6nb\u00f6z\u0151 ford\u00edt\u00f3kkal k\u00e9sz\u00edtett kimenet\u00e9t lehet megn\u00e9zni. A linkre kattintva egy egyszer\u0171 setupot kapunk, amelyen a bal oldalra \u00edrt k\u00f3dot a jobb oldalon optimaliz\u00e1l\u00e1s n\u00e9lk\u00fcli Assemblyk\u00e9nt l\u00e1thatjuk, valamint egy \"Executor\" is jelen van, amely a k\u00f3d futtat\u00e1s\u00e1t szimul\u00e1lja. (Ha nem \u00e9rdekel az assembly, azt a tabot nyugodtan bez\u00e1rhatod, telhesen f\u00fcggetlen az Executor-t\u00f3l.)</p> <p>A jegyzetben a hosszabb/bonyolultabb k\u00f3dr\u00e9szletekhez csatoltam godbolt linkeket, \u00edgy gyorsan csekkolhat\u00f3 a program fut\u00e1sa, valamint \u00edgy gyorsan bele lehet piszk\u00e1lni a k\u00f3dba.</p> <p> </p>"},{"location":"#inspiracio","title":"Inspir\u00e1ci\u00f3","text":"<p>A jegyzet inspir\u00e1ci\u00f3t mer\u00edt az infocpp(hivatalos t\u00e1rgyhonlap, tananyag), CPPFTW(hallgat\u00f3k \u00e1ltal k\u00e9sz\u00edtett majdnem k\u00e9sz jegyzet) \u00e9s a cppreference weboldal tartalm\u00e1b\u00f3l.</p> <p>K\u00f6sz\u00f6n\u00f6m a TCCPP Discord szerver tapasztalt (gcc k\u00f6zrem\u0171k\u00f6d\u0151k, C++ ISO tan\u00e1cs tagok) tagjainak az esetleges szakmai k\u00e9rd\u00e9sek megv\u00e1laszol\u00e1s\u00e1t.</p> <ul> <li>volatile</li> <li>Mr. \u03a3</li> <li>Eisenwave</li> <li>dot</li> <li>DXPower</li> <li>Mindenki, esetleg nem eml\u00edtett k\u00f6zrem\u0171k\u00f6d\u0151...</li> </ul> <p>Az \"Alapvet\u0151 k\u00fcl\u00f6nbs\u00e9gek a C nyelvt\u0151l\" fejezet alc\u00edmeit \u00e9s tartalm\u00e1t r\u00e9szben a CPPFTW oldal inspir\u00e1lta.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/","title":"Visual Studio","text":"<p>A Visual Studio a Microsoft fejleszt\u0151k\u00f6rnyezete, be\u00e9p\u00edtett devkitekkel, debuggerrel, profilerrel \u00e9s egy\u00e9b finom dolgokkal. Works out of the box, nem bonyolult a setup. H\u00e1tr\u00e1nya, hogy Windows rendszeren k\u00edv\u00fcl nem  l\u00e9tezik a Windowson haszn\u00e1lhat\u00f3 verzi\u00f3ja.</p> <p>Nem \u00f6sszekeverend\u0151 a Visual Studio Code -al.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#ajanlott-platformok","title":"Aj\u00e1nlott platformok","text":"<p>Windows</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#vs-community-edition","title":"VS Community Edition","text":"<p>A Visual Studio Community Edition teljesen ingyenesen let\u00f6lthet\u0151 a https://visualstudio.microsoft.com/free-developer-offers/ linkr\u0151l. Fontos, hogy a bal oldali, \"Visual Studio Community\" opci\u00f3t v\u00e1lasszuk, a Visual Studio Code egy teljesen m\u00e1s szoftver.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#vs-enterprise-edition","title":"VS Enterprise Edition","text":"<p>Egyetemistak\u00e9nt el\u00e9rhet\u0151 ingyenes licensz a Visual Studio Enterprise verzi\u00f3j\u00e1hoz. Ehhez el\u0151sz\u00f6r, ha m\u00e9g nem tetted meg, a https://login.bme.hu/admin/username/ oldalon kell be\u00e1ll\u00edts egy Office 365 emailt. Ebbe az emailbe egy\u00e9bk\u00e9nt Outlook-on kereszt\u00fcl egyszer\u0171en be tudsz l\u00e9pni. Ezut\u00e1n a https://azureforeducation.microsoft.com/devtools oldalon ezzel a fi\u00f3kkal bel\u00e9pve tudod a VS \u00e9s m\u00e1s hasznos(pl. Windows)  aktiv\u00e1l\u00f3 kulcsokat el\u00e9rni.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#telepites","title":"Telep\u00edt\u00e9s","text":"<p>A Visual Studio Installer program k\u00f6zpontos\u00edtva tud VS verzi\u00f3kat telep\u00edteni \u00e9s m\u00f3dos\u00edtnai. Ezt megnyitva, ha az \"Installed\" f\u00fcl\u00f6n m\u00e9g nincs ott a k\u00edv\u00e1nt verzi\u00f3(Visual Studio 2022), akkor ezt az \"Available\" f\u00fclr\u0151l lehet telep\u00edteni. A felugr\u00f3 ablakb\u00f3l a t\u00e1rgyhoz a \"Desktop Development with C++\" Workload-ra lesz csak sz\u00fcks\u00e9g. Emellett az \"Individual components\" f\u00fclr\u0151l aj\u00e1nlott m\u00e9g a \"C++ AddressSanitizer\" komponens. </p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#projekt-letrehozasa","title":"Projekt l\u00e9trehoz\u00e1sa","text":"<p>Visual Studioban a f\u0151 strukt\u00fara a k\u00f6vetkez\u0151: A root egy \"solution\" amiben t\u00f6bb project is lehet. Ez teszi lehet\u0151v\u00e9 azt, hogy komplex programokat ak\u00e1r r\u00e9szenk\u00e9nt is haszn\u00e1lhassunk. \u00daj projekt l\u00e9trehoz\u00e1s\u00e1hoz ind\u00edtsuk el a Visual Studiot, majd kattintsunk a \"Create a new project\" gombra. Ezut\u00e1n v\u00e1lasszuk az al\u00e1bbi opci\u00f3t:  Ezut\u00e1n adunk egy nevet a projectnek, kiv\u00e1lasztjuk hogy hova ker\u00fclj\u00f6n(egyetem mappa, stb.), valamint, ha nem szeretn\u00e9nk hogy a project \u00e9s a solution ugyanabban a mapp\u00e1ban legyen(nagyobb projektekn\u00e9l nem aj\u00e1nlott), akkor adunk egy k\u00fcl\u00f6n nevet a solutionnek is. </p> <p></p> <p>A Solution Explorert, ha nem jelent meg, \u00e9rdemes el\u0151hozni a View&gt;Solution Explorer opci\u00f3val. \u00c1ltal\u00e1ban az ablak jobb oldal\u00e1n jelenik meg, de szem\u00e9lyes preferencia, hogy ki hova helyezi el.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#ajanlott-beallitasok","title":"Aj\u00e1nlott be\u00e1ll\u00edt\u00e1sok","text":"<p>A Projekt\u00fcnk be\u00e1ll\u00edt\u00e1sait a \"Solution Explorer\"-ben a projektre jobbklikk&gt;Properties -re kattintva \u00e9rhetj\u00fck el. </p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#command-line-opciok","title":"Command Line opci\u00f3k","text":"<p>A Project Properties -en bel\u00fcl a C/C++&gt;Command Line f\u00fcl\u00f6n az \"Additional Options\" r\u00e9szbe tudunk command line flageket \u00edrni.</p> <p>Aj\u00e1nlott flagek:</p> <ul> <li><code>/Wall</code></li> <li><code>/WX</code> (ez a <code>Werror</code> megfelel\u0151je)</li> <li><code>/permissive-</code></li> <li><code>/fsanitize=address</code></li> </ul>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#hello-world","title":"Hello World!","text":"<p>Hozzunk l\u00e9tre egy \u00faj file-t <code>main.cpp</code> n\u00e9ven. Ezt a Solution Explorer-ben a \"Source Files\"-re jobb kattintva <code>Add&gt;New item...&gt;C++ file</code> opci\u00f3kkal tehetj\u00fck meg.</p> <p>A <code>main.cpp</code> fileba az al\u00e1bbi k\u00f3dr\u00e9szletet illesztve: <pre><code>#include &lt;iostream&gt;\n\nint main(){\n    std::cout &lt;&lt; \"Hello, World!\";\n    return 0;\n}\n</code></pre></p> <p>Majd az <code>F5</code> billenyt\u0171t le\u00fctve letesztelhetj\u00fck, hogy m\u0171k\u00fcdik -e a setupunk. </p> <p>A \"Source Files\", \"Header Files\" stb. nem val\u00f3di mapp\u00e1k, a Visual Studio \"Filter\"-nek nevezi \u0151ket, a fileok val\u00f3j\u00e1ban mind ugyanabban a mapp\u00e1ban vannak. Ez megseg\u00edti a headerekkel val\u00f3 munk\u00e1t.</p> <p>Megl\u00e9v\u0151 fileokat az \u00faj fileok l\u00e9trehoz\u00e1s\u00e1hoz hasonl\u00f3an tudunk l\u00e9trehozni, a <code>New item...</code> helyett az <code>Existing item...</code> men\u00fcpontot kell v\u00e1lasztanunk.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#cppswap-feladat-beallitasa","title":"CPPSwap feladat be\u00e1ll\u00edt\u00e1sa","text":"<p>T\u00f6lts\u00fck le a https://git.ik.bme.hu/Prog2/ell_feladat/CPPswap oldalr\u00f3l a feladat alapj\u00e1t. Ezek a fileok k\u00f6z\u00fcl a <code>.h</code> \u00e9s <code>.cpp</code> fileokra lesz sz\u00fcks\u00e9g. </p> <p></p> <p>Hozzunk l\u00e9tre egy \u00faj Visual Studio projektet. </p> <p></p> <p>M\u00e1soljuk a fentebb eml\u00edtett fileokat a projekt mapp\u00e1j\u00e1ba (ahol a <code>.vcxproj</code> file van). Csak \u00fcres mapp\u00e1ba hozzunk l\u00e9tre VS Projektet, azt\u00e1n m\u00e1soljuk be a sz\u00fcks\u00e9ges fileokat.</p> <p></p> <p>Ezut\u00e1n adjuk hozz\u00e1 a fileokat a projekthez.</p> <p></p> <p></p> <p>Ezut\u00e1n futtassuk a projektet.</p> <p>A Solution Explorerb\u0151l keress\u00fck ki a <code>swap.cpp</code> filet \u00e9s nyissuk meg.</p> <p>(A <code>#error</code> preprocesszor direkt\u00edv\u00e1val lehet sz\u00e1nd\u00e9kos ford\u00edt\u00e1sidej\u0171 hib\u00e1t tenni a k\u00f3dba hiba\u00fczenettel egy\u00fctt)</p> <p></p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#megjegyzes-a-laborfeladatokhoz","title":"Megjegyz\u00e9s a laborfeladatokhoz:","text":"<p>N\u00e9h\u00e1ny feladathoz j\u00f6n Visual Studio projekt \u00e9s solution file, alternat\u00edvak\u00e9nt ezek is haszn\u00e1lat\u00f3k. Amikor a VS felaj\u00e1nlja, hogy upgradelj\u00fck a Windows SDK-t, akkor fogadjuk el a promptot. </p> <p></p> <p></p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/1-ide-vs/#preprocessor-makro-definiciok-megadasa","title":"Preprocessor makr\u00f3 defin\u00edci\u00f3k megad\u00e1sa","text":"<p>A Project Properties &gt; C/C++ &gt; Preprocessor men\u00fcpontban a \"Preprocessor Definitions\" pontosvessz\u0151vel ell\u00e1tott list\u00e1ba lehet makr\u00f3kat defini\u00e1lni.</p> <p></p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/2-ide-clion/","title":"CLion","text":""},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/2-ide-clion/#aktivalas","title":"Aktiv\u00e1l\u00e1s","text":"<p>Note</p> <p>A CLion 2025. m\u00e1jusa \u00f3ta ingyenes non-commercial haszn\u00e1latra.</p> <p>A CLion egyetemist\u00e1k sz\u00e1m\u00e1ra ingyenes, ehhez licenszet kell ig\u00e9nyelni.</p> <p>A https://www.jetbrains.com/shop/eform/students oldalon az <code>edu.bme.hu</code> emaillel (c\u00edmt\u00e1rb\u00f3l k\u00e9sz\u00edthet\u0151) kell jelentkezni a licensz\u00e9rt.</p> <p>Egy JetBrains account -ot is k\u00e9r majd az applik\u00e1ci\u00f3 v\u00e9g\u00e9n, ennek az adatait \u00e9rdemes megjegyezni, ehhez lesz k\u00f6tve a licensz. Ha esetlen visszaigazol\u00f3 email j\u00f6n, az edus email c\u00edmet pl. Outlook -b\u00f3l (vagy b\u00e1rmilyen m\u00e1s email kliensb\u0151l) lehet el\u00e9rni.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/2-ide-clion/#cmake","title":"CMake","text":"<p>A CLion a CMake nev\u0171 build systemet haszn\u00e1lja. B\u0151vebben itt: https://nevemlaci.github.io/cpp_jegyzet/999-ide-cmake.html</p> <p>K\u00fcl\u00f6nb\u00f6z\u0151 CMake targetek k\u00f6zt v\u00e1ltani az ablak jobb fels\u0151 r\u00e9sz\u00e9ben tudunk.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/2-ide-clion/#pelda-cppswap-feladat-betoltesere","title":"P\u00e9lda CPPSwap feladat bet\u00f6lt\u00e9s\u00e9re","text":"<p>T\u00f6rl\u00fcnk mindent, ami nem C/C++ header / source file:</p> <p></p> <p></p> <p></p> <p>Ha m\u00e9g sosem volt megnyitva a CLion, vagy m\u00e9g nem lett egy CMake preset sem be\u00e1ll\u00edtva, akkor ezt az ablakot l\u00e1tjuk:</p> <p></p> <p>A t\u00e1rgy sz\u00e1m\u00e1ra az alap\u00e9rtelmezett be\u00e1ll\u00edt\u00e1sok t\u00f6k\u00e9letesen megfelelnek.</p> <p>Jobbklikk a projekt mapp\u00e1ra &gt; New &gt; CMakeLists.txt</p> <p></p> <p>Bem\u00e1soljuk a CMakeLists -be ezt:</p> <pre><code>cmake_minimum_required(VERSION 3.25) \n\nproject(prog2_elofeladatok)\n\nset(CMAKE_CXX_STANDARD 11)\n\nadd_executable(cppswap)\n</code></pre> <p>CMake -r\u0151l b\u0151vebben egy m\u00e1sik fejezetben m\u00e1r \u00edrtam.</p> <p>Kiv\u00e1lasztjuk az \u00f6sszes C/C++ header / source file -t &gt; Jobb klikk &gt; Add to CMake Project (Ha ez az opci\u00f3 nem jelenik meg, akkor a CMakeLists.txt -re jobb klikk &gt; Load CMake Project)</p> <p></p> <p></p> <p>Jobb klikk CMakeLists.txt -re &gt; Reload CMake Project</p> <p></p> <p>Jobb fent valami ilyesminek k\u00e9ne megjelennie: </p> <p></p> <p>A z\u00f6ld h\u00e1romsz\u00f6gre kattintva lehet a kiv\u00e1lasztott target-et elind\u00edtani, a bog\u00e1rra kattintva lehet debuggert ind\u00edtani.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/3-ide-cmake/","title":"CMake","text":"<p>A CMake egy meta-build system. Ez azt jelenti, hogy \u00f6nmag\u00e1ban nem funkcion\u00e1lis, sz\u00fcks\u00e9g van mell\u00e9 egy C++ compilerre (pl. MSVC, g++, stb.) \u00e9s egy build systemre is. Emell\u00e9 sz\u00fcks\u00e9g lesz m\u00e9g egy build systemre. Egy egyszer\u0171 de nagyon gyors build system a Ninja.</p> <p>A CMake el\u0151nye, hogy oper\u00e1ci\u00f3s rendszert\u0151l \u00e9s ford\u00edt\u00f3t\u00f3l f\u00fcggetlen\u00fcl m\u0171k\u00f6dik.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/3-ide-cmake/#miert-pont-cmake","title":"Mi\u00e9rt pont CMake?","text":"<p>A VS Code be\u00e9p\u00edtett task rendszere el\u00e9g janky egy norm\u00e1lis build system n\u00e9lk\u00fcl, a CLion pedig kb. csak a CMake projekteket k\u00e9pes \u00e9rtelmesen kezelni.</p>"},{"location":"Fejleszt%C5%91k%C3%B6rnyezetek/3-ide-cmake/#cmake-alapok","title":"CMake alapok","text":"<p>A <code>CMakeLists.txt</code> file \u00edrja le a projekt buildel\u00e9s\u00e9t. Gondolhatunk r\u00e1 \u00fagy, mint a \"script\"re.</p> <pre><code>cmake_minimum_required(VERSION 3.25) #megadunk egy cmake verzi\u00f3t amire minimum sz\u00fcks\u00e9g lesz\n\nproject(prog2) #csin\u00e1lunk egy projektet\n\nset(CMAKE_CXX_STANDARD 11) # a set() f\u00fcggv\u00e9nnyel v\u00e1ltoz\u00f3knak adhatunk \u00e9rt\u00e9ket.\n\n\n#az add_executable f\u00fcggv\u00e9nyben megadunk konkr\u00e9t futtathat\u00f3 v\u00e9geredm\u00e9nyeket, mellette felsoroljuk a hozz\u00e1 tartoz\u00f3 forr\u00e1sf\u00e1jlokat\nadd_executable(labor1 fuggvenyeim.h fuggvenyeim.cpp)\n\n#egy projekthez t\u00f6bb executable is tartozhat\nadd_executable(labor1_test test.cpp)\n</code></pre>"},{"location":"H%C3%A1zi/nhf/","title":"H\u00e1zi feladat tippek","text":""},{"location":"H%C3%A1zi/nhf/#nagyhazi-linkek","title":"Nagyh\u00e1zi linkek:","text":"<p>ki\u00edr\u00e1s,  \u00f6tletek,  pontoz\u00e1si \u00fatmutat\u00f3,  p\u00e9lda nhf</p>"},{"location":"H%C3%A1zi/nhf/#kompozicio-es-adattagok","title":"Kompoz\u00edci\u00f3 \u00e9s adattagok","text":"<p>Ha <code>A</code> tartalmazza <code>B</code>-t, akkor nem kell <code>A</code>-ban egy <code>B</code> t\u00edpus\u00fa adattag \u00c9S kompoz\u00edci\u00f3 a kettej\u00fck k\u00f6zt. El\u00e9g a kompoz\u00edci\u00f3 \u00e9s annak elnevez\u00e9se:</p> <p>Emellett \u00e9rdemes jel\u00f6lni a sz\u00e1moss\u00e1got: <code>min_amount .. max_amount</code>. A v\u00e9gtelent a <code>*</code> jel\u00f6li.</p> <p>A p\u00e9ld\u00e1n egy kuty\u00e1kat nyilv\u00e1ntart\u00f3 adatb\u00e1zis p\u00e9lda l\u00e1that\u00f3: </p>"},{"location":"H%C3%A1zi/nhf/#hf-tesztelese-felteteles-forditas","title":"HF tesztel\u00e9se, felt\u00e9teles ford\u00edt\u00e1s","text":"<p>A JPorta a h\u00e1zikat C++17 m\u00f3dban, <code>-Werror -Wall -pedantic</code> warning flagekkel ford\u00edtja.</p> <p>A JPorta defini\u00e1lja a <code>CPORTA</code> makr\u00f3t, ennek seg\u00edts\u00e9g\u00e9vel lehet k\u00f3dot csak JPort\u00e1n, vagy csak nem JPort\u00e1n ford\u00edtani:</p> <pre><code>#ifdef CPORTA\n//ez csak jport\u00e1n fut\n#endif\n\n#ifndef CPORTA\n//ez csak akkor fut, ha nem JPorta ford\u00edtotta\n#endif\n\n//ket\u0151 egyben (ifelse)\n\n#ifdef CPORTA\n//csak jporta\n#else\n//csak nem jporta\n#endif\n</code></pre>"},{"location":"H%C3%A1zi/nhf/#input-es-output-mockolas","title":"Input \u00e9s output mockol\u00e1s","text":"<p>Tegy\u00fck fel hogy van n\u00e9h\u00e1ny m\u00e1r elk\u00e9sz\u00edtett teszt makr\u00f3nk. Ilyeneket lehet pl a <code>gtest_lite</code> felhaszn\u00e1l\u00e1s\u00e1val szerezni.</p> <ul> <li><code>EXPECT_EQ</code>: egyenl\u0151s\u00e9get v\u00e1r el a k\u00e9t argumentuma k\u00f6zt</li> <li><code>EXPECT_THROW</code>: kiv\u00e9telt v\u00e1r</li> </ul> <p>Ha azt szeretn\u00e9nk tesztelni, hogy j\u00f3l reag\u00e1l -e adott inputra a program, akkor van k\u00e9t opci\u00f3nk: * Standard inputr\u00f3l olvasunk egy egys\u00e9gtesztben: ezt nem szeretj\u00fck * \"Mock\" -olunk egy inputot, ezt szok\u00e1s csin\u00e1lni</p> <p>Ehhez az <code>std::stringstream</code> t\u00edpust fogjuk haszn\u00e1lni. Ez hasonl\u00f3, mint az eddig megismert standard IO streamek. A stringstream egy bels\u0151 karaktert\u00f6mbbe \u00edr \u00e9s onnan olvas. Tetsz\u0151legesen \u00edrhatunk bele \u00e9s olvashatunk is bel\u0151le, nagyon hasznos, k\u00f6nnyen lehet vele pl. sz\u00e1m &gt; string konverzi\u00f3t v\u00e9gezni. Az <code>sstream</code> standard headerben tal\u00e1lhat\u00f3.</p> <p>Most egy egyszer\u0171 k\u00e9tdimenzi\u00f3s vektorhoz \u00edrunk k\u00e9t tesztet: <pre><code>std::stringsteam mocked_input;\nmocked_input &lt;&lt; \"1, 2\"; //beletessz\u00fck az adatokat az elv\u00e1rt form\u00e1tumban\nvec2 v;\nmocked_input &gt;&gt; v; //kiolvassuk a vektorba az adatokat\nEXPECT_EQ(vec2(1, 2), v);\n</code></pre></p> <p>Most pedig egy teszt, ahol sz\u00e1nd\u00e9kosan rossz form\u00e1tumot haszn\u00e1lunk: <pre><code>std::stringsteam mocked_input;\nmocked_input &lt;&lt; \"1| 2\"; //beletessz\u00fck az adatokat sz\u00e1nd\u00e9kosan rossz form\u00e1ban\nvec2 v;\nEXPECT_THROW(mocked_input &gt;&gt; v); //hib\u00e1s volt a bemenet, ez\u00e9rt kiv\u00e9telt v\u00e1runk\n</code></pre></p>"},{"location":"H%C3%A1zi/nhg-igy/","title":"Nagyh\u00e1zi tervez\u00e9s, avagy \u00edgy \u00edrjunk nagyh\u00e1zit.","text":"<p>A tant\u00e1rgy egyik nagy k\u00f6vetelm\u00e9nye egy nagyh\u00e1zi feladat elk\u00e9sz\u00edt\u00e9se. Ez az oldal ennek a tervez\u00e9s\u00e9hez ny\u00fajt seg\u00edts\u00e9get, hiszen egy rosszul tervezett/elkezdett h\u00e1zi feladatot sokszor neh\u00e9z jav\u00edtani.</p>"},{"location":"H%C3%A1zi/nhg-igy/#dinamikus-tarolo-tervezese","title":"Dinamikus t\u00e1rol\u00f3 tervez\u00e9se","text":"<p>Minden h\u00e1zihoz sz\u00fcks\u00e9ges lesz egy dinamikus t\u00e1rol\u00f3 megtervez\u00e9se. A legt\u00f6bb nyilv\u00e1ntart\u00e1sos feladatban el\u00e9g egy dinamikus t\u00f6mb, esetleg l\u00e1ncolt lista (b\u00e1r ezzel nehezebb dolgozni).</p> <p>Mivel a legt\u00f6bb h\u00e1ziban nem megengedett az STL t\u00e1rol\u00f3k haszn\u00e1lata, ez\u00e9rt ezeket a t\u00e1rol\u00f3kat nek\u00fcnk kell implement\u00e1lni.</p> <p>A h\u00e1zit \u00e9rdemes a t\u00e1rol\u00f3val kezdeni, ezzel ut\u00e1na lehet dolgozni. </p> <p>A t\u00e1rol\u00f3kat \u00e9rdemes az al\u00e1bbiak alapj\u00e1n elkezdeni:</p> <ul> <li>Tudjon minden t\u00edpust t\u00e1rolni (template)</li> <li>Lehessen bele elemeket besz\u00farni (ha a feladathoz kell, akkor megadott indexre)</li> <li>Lehessen bel\u0151le elemeket t\u00f6r\u00f6lni</li> <li>Kezeljen minden mem\u00f3ri\u00e1t, ne kelljen k\u00edv\u00fclr\u0151l mem\u00f3ri\u00e1t kezelni</li> <li>Ha lista, vagy egy\u00e9b \"Node\" alap\u00fa t\u00e1rol\u00f3, akkor ezeket a nodeokat ne kelljen k\u00edv\u00fclr\u0151l piszk\u00e1lni</li> <li>Ha dinamikus t\u00f6mb, akkor mindenk\u00e9pp lehessen indexelni (ez list\u00e1n\u00e1l lass\u00fa, ink\u00e1bb iter\u00e1torokkal legyen megoldva)</li> <li>Lehessen iter\u00e1torokkal is l\u00e9pkedni rajta, list\u00e1n\u00e1l f\u0151leg fontos</li> </ul> <p>Ha heterog\u00e9n t\u00e1rol\u00f3 kell, akkor implement\u00e1ljunk egyet, ami az el\u0151z\u0151 pontok alapj\u00e1n implement\u00e1lt dinamikus t\u00e1rol\u00f3t haszn\u00e1lja.</p> <p>A t\u00e1rol\u00f3 implement\u00e1l\u00e1sa nagyon fontos, hiszen ezut\u00e1n minden \"hmm ebb\u0151l t\u00f6bb is k\u00e9ne\" probl\u00e9m\u00e1t megoldottunk.</p>"},{"location":"H%C3%A1zi/nhg-igy/#alapveto-osztalyok-megtervezese","title":"Alapvet\u0151 oszt\u00e1lyok megtervez\u00e9se","text":""},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/","title":"Alapvet\u0151 k\u00fcl\u00f6nbs\u00e9gek a C nyelvt\u0151l","text":""},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#a-bool-mint-nyelvi-elem","title":"A <code>bool</code>, mint nyelvi elem","text":"<p>https://en.cppreference.com/w/cpp/language/types#Boolean_type</p> <p>A <code>bool</code> t\u00edpus, hab\u00e1r a C nyelv \u00fajabb verzi\u00f3iban nyelvi elemk\u00e9nt szerepel, a Prog1 m\u00e9g nem tan\u00edtja. A C++ nyelvnek szerencs\u00e9re r\u00e9sze a <code>bool</code> t\u00edpus, nem kell ehhez a leg\u00fajabb verzi\u00f3kat haszn\u00e1lni.</p> <pre><code>bool x = true; //nem kell semmilyen include\n</code></pre>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#struktura-es-typedef","title":"Strukt\u00fara \u00e9s typedef","text":"<p>A C nyelvben a strukt\u00far\u00e1k \u00f6nmagukban nem, csak a <code>struct</code> el\u0151taggal voltak egy\u00e9ni t\u00edpusnevek. Ez C++ -ban m\u00e1sk\u00e9pp van, itt a strukt\u00fara neve <code>typedef</code> n\u00e9lk\u00fcl is egy\u00e9ni t\u00edpusn\u00e9v.</p> <pre><code>struct foo{\n    int a;\n};\n\nint main(){\n    foo f;\n    f.a = 5;\n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#c-standard-library-headerek","title":"C Standard Library headerek","text":"<p>A C standard library header-jei a C++ nyelvben is l\u00e9teznek, viszont a <code>.h</code> kiterjeszt\u00e9st elvesztett\u00e9k, \u00e9s egy <code>c</code> el\u0151tagot kaptak. Pl. <pre><code>#include &lt;stdio.h&gt; -&gt; #include &lt;cstdio&gt;\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#nevterek-namespace","title":"N\u00e9vterek (namespace)","text":"<p>https://en.cppreference.com/w/cpp/language/namespace</p> <p>C-ben gyakori az, hogy egy n\u00e9v m\u00e1r haszn\u00e1lva van p\u00e9ld\u00e1ul egy header file-ban ez\u00e9rt b\u00e1rhol, ahol ez a header include-olva van, ez a n\u00e9v \"foglalt\" lesz. Ezt sok k\u00f6nyvt\u00e1r a n\u00e9v prefixel\u00e9s\u00e9vel oldja meg, pl. <code>SDL_Texture</code>.</p> <p>Erre a C++ -nak be\u00e9p\u00edtett nyelvi eleme van, ezek pedig a n\u00e9vterek.</p> <pre><code>#include &lt;cstdio&gt;\n\nnamespace foo{\n    void f(){\n        std::printf(\"foo\");\n    }\n\n    namespace bar{\n        void f(){\n            std::printf(\"bar\");\n        }\n    }\n}\n\nint main(){\n    foo::f();\n    foo::bar::f();\n}\n</code></pre> <p>A n\u00e9vtereken bel\u00fcli neveket a <code>::</code> oper\u00e1torral \u00e9rhetj\u00fck el. A <code>printf</code> el\u0151tti <code>std</code> n\u00e9vt\u00e9r a standard library n\u00e9vtere, ez tartalmazza az \u00f6sszes standard library \u00e1ltal tartalmazott szimb\u00f3lumot (f\u00fcggv\u00e9nyek, strukt\u00far\u00e1k, stb.), \u00e9ppen az\u00e9rt, hogy az stdlib \u00e1ltal haszn\u00e1lt gyakori nevek (pl. vector) ne \u00fctk\u00f6zzenek m\u00e1s k\u00f3ddal.</p>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#using-namespace","title":"using, namespace","text":"<p>A <code>using namespace</code> kulcsszavakkal bevonhat\u00f3 egy eg\u00e9sz n\u00e9vt\u00e9r szimb\u00f3lumt\u00e1ra a jelenlegi ford\u00edt\u00e1si egys\u00e9gbe (forr\u00e1sf\u00e1jl). </p> <pre><code>using namespace std;\n\nint main() {\n    printf(\"bar\");\n}\n</code></pre> <p>Hab\u00e1r a lehet\u0151s\u00e9g megvan r\u00e1, ezt soha ne haszn\u00e1ljuk, f\u0151leg nem az <code>std</code> n\u00e9vt\u00e9rrel!</p> <p>Lehet\u0151s\u00e9g van adott szimb\u00f3lumok beemel\u00e9s\u00e9re, pl. </p> <pre><code>using std::printf\n\nint main() {\n    printf(\"bar\");\n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#argument-dependent-lookup","title":"Argument Dependent Lookup","text":"<p>A non-qualified f\u00fcggv\u00e9nyek h\u00edv\u00e1sakor a f\u00fcggv\u00e9ny argumentumainak a n\u00e9vter\u00e9ben tal\u00e1lhat\u00f3 szimb\u00f3lumok k\u00f6zt is t\u00f6rt\u00e9nik keres\u00e9s.</p> <p>Non-qualified : Minden olyan n\u00e9v, ami nem egy scope (::) oper\u00e1tort\u00f3l jobbra \u00e1ll.</p> <p>Pl. <code>foo</code> -&gt; non-qualified , <code>::foo</code> -&gt; qualified</p> <pre><code>namespace A\n{\n    struct X;\n    struct Y;\n\n    void f(int);\n    void g(X);\n}\n\nnamespace B\n{\n    void f(int i)\n    {\n        f(i); // B::f -et h\u00edvja\n    }\n\n    void g(A::X x)\n    {\n        g(x); // Error: nem tudunk B::g \u00e9s A::g k\u00f6z\u00f6tt d\u00f6nteni, mert az A::X miatt az A namespaceben is keres\n    }\n\n    void h(A::Y y)\n    {\n        h(y); // B::h h\u00edv\u00e1s: ADL keresi A::h -t, de nem tal\u00e1l ilyet, sz\u00f3val B::h h\u00edv\u00e1s t\u00f6rt\u00e9nik\n    }\n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#function-overloading","title":"Function overloading","text":"<p>C++ -ban ugyanazon nev\u0171 f\u00fcggv\u00e9ny t\u00f6bbf\u00e9le param\u00e9tereket vehet \u00e1t.</p> <pre><code>#include &lt;cstdio&gt;\n\nvoid foo(double x){\n    std::printf(\"%lf double\", x);\n}\n\nvoid foo(int x){\n    std::printf(\"%d int\", x);\n}\n\nint main(){\n    foo(5); // 5 int\n    foo(3.2); // 3.2 double\n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#referenciak","title":"Referenci\u00e1k","text":"<p>C-b\u0151l ismert a pointerek fogalma. Ezt sokszor arra haszn\u00e1ljuk, hogy egy f\u00fcggv\u00e9nyben a param\u00e9terk\u00e9nt kapott eredeti objektumot m\u00f3dos\u00edtsuk, vagy hogy egy m\u00e1sol\u00e1st elker\u00fclj\u00fcnk. Erre val\u00f3k C++ban a referenci\u00e1k</p> <pre><code>//swap f\u00fcggv\u00e9ny C-ben\n\nvoid c_swap(int* x, int* y){\n    int tmp = *x;\n    *x = *y;\n    *y = tmp;\n}\n\n//swap C++ -ban\nvoid cpp_swap(int&amp; x, int&amp; y){\n    int tmp = x;\n    x = y;\n    y = tmp;\n}\n</code></pre> <p>A referenci\u00e1k konstansok, azaz egy referencia az \u00e9lettartama alatt nem tud hirtelen m\u00e1sik objektumra mutatni. <pre><code>int x = 5;\nint y = 1;\nint&amp; xr = x;\nxr = y; //ugyan az, mint x = y;\n</code></pre> Gondolhatunk a referenci\u00e1ra \u00fagy, mint egy 'alias' -ra (alternat\u00edv n\u00e9v). Megmondjuk, minek az alias-a, majd ut\u00e1na az eredeti v\u00e1ltoz\u00f3 helyett haszn\u00e1ljuk.</p> <p>Fontos megjegyezni, hogy ugyan \u00fagy mint a pointerekn\u00e9l, lok\u00e1lis v\u00e1ltoz\u00f3ra mutat\u00f3 referenci\u00e1val tilos visszat\u00e9rni.</p>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#a-const-kulcsszo","title":"A const kulcssz\u00f3","text":"<p>https://en.cppreference.com/w/cpp/language/cv</p> <p>Most a <code>const</code> type qualifier-r\u0151l van sz\u00f3.</p> <p>A <code>const</code> kulcssz\u00f3 a C nyelvnek is r\u00e9sze, viszont C++ban egy sokkal fontosabb szerepe van, amivel k\u00e9s\u0151bb tal\u00e1lkozunk m\u00e9g.</p> <p>Jelent\u00e9se nev\u00e9b\u0151l ad\u00f3dik, egy <code>const</code> objektumot \"nem lehet megv\u00e1ltoztatni\". A kulcssz\u00f3 mindig a t\u0151le azonnal balra tal\u00e1lhat\u00f3 dologra vonatkozik, kiv\u00e9ve ha a <code>const</code> az els\u0151, akkor a t\u0151le azonnal jobbra tal\u00e1lhat\u00f3 elemre vonatkozik.  Fontos azt megeml\u00edteni, hogy a <code>const</code> nem ford\u00edt\u00e1sidej\u0171 konstans \u00e9rt\u00e9ket jel\u00f6l, ink\u00e1bb a programoz\u00f3 fel\u00e9 jelz\u00e9s. R\u00e9gebben a ford\u00edt\u00f3k optimaliz\u00e1l\u00e1sra is haszn\u00e1lt\u00e1k, viszont ennek a jelent\u0151s\u00e9ge ma m\u00e1r eleny\u00e9sz\u0151, viszont a kulcssz\u00f3 haszn\u00e1lata ett\u0151l m\u00e9g esszenci\u00e1lis marad.</p> <p>P\u00e9l\u00e1k: <pre><code>int x; // sima, v\u00e1ltoztathat\u00f3 eg\u00e9sz\nint const pi = 3.14; //konstans eg\u00e9sz\nconst int pi = 3.14; //ugyanaz, mint az el\u0151z\u0151\n\nconst int* p = &amp;pi; // pointer egy konstans eg\u00e9szre\nint const * p = &amp;pi; //ugyanaz, mint az el\u0151z\u0151\n\nconst int&amp; p = pi; //referencia konstans eg\u00e9szre\nint const&amp; p = pi; //ugyanaz, mint az el\u0151z\u0151\n\n//most j\u00f6n a l\u00e9nyeg\n\nconst int* const c = &amp;pi; //konstans pointer konstans eg\u00e9szre\nint const * const c = &amp;pi; //ugyanaz, mint az el\u0151z\u0151\n\nint* const c = &amp;x; // konstans pointer v\u00e1ltoztathat\u00f3 eg\u00e9szre\n\n/*!!!---!!!*/\n//az al\u00e1bbi k\u00f3dr\u00e9szletek pedig nem m\u0171k\u00f6dnek, mivel konstans objektumra csak pointer-to-const \u00e9s reference-to-const mutathat\n\n//mivel pi const, ez\u00e9rt csak pointer-to-const mutathat r\u00e1\nint* const c = &amp;pi; \n\n//mivel pi const, ez\u00e9rt csak reference-to-const refer\u00e1lhat r\u00e1\nint&amp; r = pi; \n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#null-pointer","title":"Null pointer","text":"<p>https://en.cppreference.com/w/cpp/language/nullptr</p> <p>A r\u00e9gebbi (prog1en oktatott) C verzi\u00f3kban a <code>NULL</code> val\u00f3j\u00e1ban a konstans 0 void* -\u00e9 kasztol\u00e1sa. C++ban a <code>void*</code> -&gt; <code>T*</code> konverzi\u00f3 nem implicit, \u00edgy C++ban a null pointernek saj\u00e1t <code>std::nullptr_t</code> t\u00edpusa van, \u00e9s <code>nullptr</code> -k\u00e9nt hivatkozunk r\u00e1 a k\u00f3dban. Az <code>std::nullptr_t</code> t\u00edpust a saj\u00e1t k\u00f3dunkban nem fogjuk haszn\u00e1lni, viszont annyit kell tudni r\u00f3la, hogy b\u00e1rmilyen pointer t\u00edpuss\u00e1 \u00e9s <code>bool</code>-ra is k\u00e9pes implicit konvert\u00e1l\u00f3dni, azaz m\u0171k\u00f6dnek a <pre><code>int* a = nullptr;\n\nif(a) {\n\n}\n</code></pre> k\u00f3dr\u00e9szletek.</p>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#auto-c11","title":"<code>auto</code> (C++11)","text":"<p>Az <code>auto</code> kulcssz\u00f3 t\u00edpus hely\u00e9re \u00edrhat\u00f3, ahol a t\u00edpus levezethet\u0151 pl. visszat\u00e9r\u00e9si \u00e9rt\u00e9kb\u0151l. Fontos, hogy az <code>auto</code> nem vezeti le a <code>const</code>, <code>volatile</code> kvalifik\u00e1ckat \u00e9s a referenci\u00e1kat.</p> <pre><code>auto x = 5; //int x = 5;\n\nauto&amp; y = array.at(5); //referencia egy t\u00f6mb 5. elem\u00e9re\n\nauto z = array.at(5); //egy t\u00f6mb 5. elem\u00e9nek m\u00e1solata\n</code></pre>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#stdstring","title":"std::string","text":"<p>https://en.cppreference.com/w/cpp/string/basic_string</p> <p>Egy egyszer\u0171 string t\u00edpus dinamikus m\u00e9rettel \u00e9s alap elv\u00e1rt string funkcionalit\u00e1ssal.</p> <pre><code>#include &lt;string&gt;\n/* ... */\nstd::string str = \"foo\";\nstd::string str2 = str;\n\nstr = str.substr(0, 1);\n// ...\n</code></pre>"},{"location":"T%C3%B6rzsanyag/1-alapveto-kulonbsegek/#scoped-enumc11","title":"Scoped enum(C++11)","text":"<p>https://en.cppreference.com/w/cpp/language/enum</p> <p>A C <code>enum</code> t\u00edpusai nagyon furcs\u00e1n viselkednek, eg\u00e9ssz\u00e9 v\u00e1ltoznak ha kicsit f\u00e9loldalasan n\u00e9zz\u00fck \u0151ket, pedig nem igaz\u00e1n erre val\u00f3k. C++ban az <code>enum class</code> ezt oldja meg.  Defin\u00edci\u00f3s szintaxisuk a C enumokhoz hasonl\u00f3, viszont a scoped enum-ok nem konvert\u00e1l\u00f3dnak automatikusan eg\u00e9sz sz\u00e1mokk\u00e1, valamint nem valami m\u00e1gikus glob\u00e1lis konstansk\u00e9nt pr\u00f3b\u00e1lnak viselkedni. <pre><code>enum class Direction{\n    UP=0, DOWN=1, LEFT=2, RIGHT=3\n};\n\nint main(){\n    Direction d = Direction::UP; //typename::enumname szintaxis\n    int x = d; //error\n}\n</code></pre></p> <p>M\u00e9g egy nagyon j\u00f3 tulajdons\u00e1guk, hogy megadhatjuk az underlying t\u00edpusukat. P\u00e9ld\u00e1ul ha tudjuk hogy max 1 bytera lesz sz\u00fcks\u00e9g\u00fcnk, akkor megmondhatjuk neki, hogy val\u00f3j\u00e1ban egy speck\u00f3 <code>char</code> legyen. <pre><code>enum class Direction : char{\n    UP=0, DOWN=1, LEFT=2, RIGHT=3\n};\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/10-heterogen_kollekcio/","title":"Heterog\u00e9n t\u00e1rol\u00f3k","text":"<p>A heterog\u00e9n kollekci\u00f3k l\u00e9nyege az, hogy t\u00f6bbf\u00e9le t\u00edpus\u00fa elemeket t\u00e1rolhatunk egy t\u00e1rol\u00f3ban. Erre sokf\u00e9le m\u00f3dszer l\u00e9tezik, most a legegyszer\u0171bb form\u00e1j\u00e1t n\u00e9zz\u00fck meg.</p>"},{"location":"T%C3%B6rzsanyag/10-heterogen_kollekcio/#polimorphism-by-inheritance","title":"Polimorphism by inheritance","text":"<p>Az \u00f6r\u00f6kl\u00e9s alap\u00fa polimorfizmus alapja az el\u0151z\u0151 fejezetben is eml\u00edtett \u00f6r\u00f6kl\u00e9ses mem\u00f3riak\u00e9p: </p> <p>Ezen l\u00e1thatjuk, hogy egy <code>struct B : A</code> oszt\u00e1ly egy p\u00e9ld\u00e1nya egyben egy <code>A</code> oszt\u00e1ly p\u00e9ld\u00e1nya is, ez\u00e9rt <code>A</code> t\u00edpusra mutat\u00f3 pointer/referencia mutathat <code>B</code> p\u00e9ld\u00e1nyra is.</p> <p>Ezek alapj\u00e1n k\u00e9sz\u00edthet\u00fcnk egy olyan t\u00e1rol\u00f3t, amely egy adott t\u00edpusb\u00f3l lesz\u00e1rmaz\u00f3 objektumokra mutat\u00f3 pointereket t\u00e1rol. Az ilyen t\u00e1rol\u00f3kat h\u00edvjuk heterog\u00e9n kollekci\u00f3nak.</p> <p>Ownership k\u00e9rd\u00e9s: Egy heterog\u00e9n kollekci\u00f3 eset\u00e9n k\u00e9t opci\u00f3nk van:</p> <ul> <li>A kollekci\u00f3 birtokolja a t\u00e1rolt objektumokat. Ez azt jelenti, hogy a kollekci\u00f3 \u00e9lettartama v\u00e9g\u00e9n fel kell szabad\u00edtania a t\u00e1rolt elemeket. </li> <li>A kollekci\u00f3 nem birtokolja az elemeket, ekkor a felhaszn\u00e1l\u00f3 feladata az elemek felszabad\u00edt\u00e1sa.</li> </ul> <p>Heterog\u00e9n kollekci\u00f3k eset\u00e9n \u00e1ltal\u00e1ban az els\u0151 opci\u00f3t v\u00e1lasztjuk.</p>"},{"location":"T%C3%B6rzsanyag/10-heterogen_kollekcio/#heterogen-kollekcio-konstrukcioja","title":"Heterog\u00e9n kollekci\u00f3 konstrukci\u00f3ja","text":"<p>T\u00e1roljunk \"komponens\"eket, amelyeknek van egy virtu\u00e1lis <code>use()</code> tagf\u00fcggv\u00e9nye. Sz\u00fcks\u00e9g\u00fcnk lesz: * Valamilyen <code>Component*</code> t\u00f6mbre * M\u00e9retet t\u00e1rol\u00f3 eg\u00e9szre * hozz\u00e1ad\u00f3 tagf\u00fcggv\u00e9nyre * indexel\u0151 oper\u00e1torra * destruktorra * m\u00e1sol\u00f3 konstruktorra \u00e9s \u00e9rt\u00e9kad\u00f3 oper\u00e1torra(vagy ha nem kell, akkor priv\u00e1tt\u00e1 tessz\u00fck ezeket, C++11 -t\u0151l <code>= delete;</code> is j\u00f3)</p> <p>Az els\u0151 k\u00e9t pontot egyes\u00edthetj\u00fck egy <code>std::vector&lt;Container*&gt;</code> haszn\u00e1lat\u00e1val(C++ standard library dinamikus t\u00f6mbje), vagy egy saj\u00e1t dinamikus t\u00f6mb implement\u00e1ci\u00f3val. (ld. el\u0151z\u0151 fejezet)</p> <p>A hozz\u00e1ad\u00f3 tagf\u00fcggv\u00e9ny\u00fcnk egy <code>Container*</code>-ot vesz \u00e1t, amit a h\u00edv\u00f3 f\u00e9l a <code>new</code> oper\u00e1tor visszat\u00e9r\u00e9si \u00e9rt\u00e9kek\u00e9nt kapott. Ez a f\u00fcggv\u00e9ny \"\u00e1tveszi a birtokos szerep\u00e9t\"(takes ownership) a h\u00edv\u00f3t\u00f3l. Ezt \u00e9rdemes kommentk\u00e9nt jelezni.</p> <p> Futtasd!  <pre><code>#include &lt;cstdint&gt;\n#include &lt;vector&gt;\n#include &lt;iostream&gt;\n\nstruct Component{\n    virtual void use() = 0;\n    virtual ~Component() = default;\n};\n\nstruct SomeComponent : Component{\n    SomeComponent(int gears) : gears(gears) {}\n    int gears;\n    virtual void use() override{\n        fixSimpleMachine();\n    }\n\n    void fixSimpleMachine() {\n        std::cout &lt;&lt; \"fixed simple machine, gears: \" &lt;&lt; gears &lt;&lt; '\\n';\n    }\n    virtual ~SomeComponent() = default;\n};\n\nstruct ComponentStore{\n    ComponentStore() = default;\n\n    std::size_t size() const { return components.size(); }\n\n    void push_back(Component* component) {\n        components.push_back(component);\n    }\n\n    Component* operator[](std::size_t idx){\n        return components[idx];\n    }\n\n    ~ComponentStore(){\n        for(size_t i = 0; i &lt; size(); i++){ //range based for ciklus, ld. iter\u00e1torok\n            delete components[i];\n        }\n    }\n\n    private:\n        ComponentStore(const ComponentStore&amp;);\n        ComponentStore&amp; operator=(const ComponentStore&amp;);\n        std::vector&lt;Component*&gt; components;\n};\n\nint main(){\n    ComponentStore components;\n    components.push_back(new SomeComponent(5));\n    components[0]-&gt;use(); \n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/10-heterogen_kollekcio/#kitero-stdunique_ptr-c11-tol","title":"Kit\u00e9r\u0151: std::unique_ptr (C++11 -t\u0151l)","text":"<p><code>&lt;memory&gt;</code> header</p> <p>Note</p> <p>Ez a fejezet t\u00falmutat a t\u00e1rgy anyag\u00e1n. A <code>unqiue_ptr</code> komolyabb haszn\u00e1lat\u00e1hoz sokszor sz\u00fcks\u00e9gesebb bonyolultabb koncepci\u00f3k, amelyeket a jegyzet v\u00e9g\u00e9n \"kit\u00e9r\u0151\" fejezetekben t\u00e1rgyal.</p> <p>Gyakran szeretn\u00e9nk egy dinamikusan foglalt objektumot valamilyen m\u00e1sik objektum \u00e9lettartam\u00e1hoz k\u00f6tni. Erre az esetre l\u00e9tezik egy pointert csomagol\u00f3 <code>std::unique_ptr</code> oszt\u00e1ly. Ugyan\u00fagy m\u0171k\u00f6dik, mint egy pointer, van <code>*</code> \u00e9s <code>-&gt;</code> oper\u00e1tora, viszont a <code>unique_ptr</code> objektum \u00e9lettartama v\u00e9g\u00e9n felszabad\u00edtja a t\u00e1rolt pointert. Nem m\u00e1solhat\u00f3(hiszen \"unique\"), ezzel biztos\u00edtja, hogy egyszerre csak egy objektum birtokolja a mem\u00f3ri\u00e1t, amire mutat. Referencia param\u00e9terk\u00e9nt term\u00e9szetesen \u00e1tvehet\u0151, ez nem okoz m\u00e1sol\u00e1st.</p> <p>A <code>unqiue_ptr</code>-hez az <code>std::make_unique</code> f\u00fcggv\u00e9nnyel tudunk objektumot foglalni. Amit param\u00e9terk\u00e9nt adunk neki, azt tov\u00e1bbadja az objektum konstruktor\u00e1nak. Emellett a <code>uniqure_ptr</code> konstruktora kaphat m\u00e1r lefoglalt objektumra mut\u00f3 pointert is.</p> <pre><code>std::unique_ptr&lt;Foo&gt; p = std::make_unique&lt;Foo&gt;(3, \"bar\"); //Foo* p = new Foo(3, \"bar\")\nFoo* f = new Foo(2, \"asd\");\nstd::unqiue_ptr&lt;Foo&gt; p2(f); //p2 takes ownership of f, so delete f; is not necessary\n</code></pre> <p><code>unique_ptr</code> -el \u00e1t\u00edrva a heterog\u00e9n kollekci\u00f3nkat:</p> <p><pre><code>struct ComponentStore{\n    ComponentStore() = default;\n\n    std::size_t size() const { return components.size(); }\n\n    void push_back(Component* component) {\n        components.push_back(std::unique_ptr&lt;Component&gt;(component));\n    }\n\n    std::unique_ptr&lt;Component&gt;&amp; operator[](std::size_t idx){\n        return components[idx];\n    }\n\n    ~ComponentStore() = default; \n\n    private:\n        ComponentStore(const ComponentStore&amp;);\n        ComponentStore&amp; operator=(const ComponentStore&amp;);\n        std::vector&lt;std::unique_ptr&lt;Component&gt;&gt; components;\n};\n</code></pre> \u00cdgy m\u00e1r nem kell explicit destruktor, az std::vector destruktora megh\u00edvja az elemeinek destruktor\u00e1t. A <code>unqiue_ptr</code> destruktora pedig felszabad\u00edtja a mem\u00f3ri\u00e1t.</p>"},{"location":"T%C3%B6rzsanyag/11-iteratorok/","title":"Iter\u00e1torok","text":"<p>Az iter\u00e1tor egy olyan t\u00edpus, amely \u00e1ltal\u00e1nos (generikus) m\u00f3don k\u00e9pes iter\u00e1lni egy t\u00e1rol\u00f3n.  Az iter\u00e1torok okos pointerek, seg\u00edts\u00e9g\u00fckkel ugyanazzal az interf\u00e9sszel iter\u00e1lhatunk k\u00fcl\u00f6nb\u00f6z\u0151 kont\u00e9nereket.</p> <p>Iter\u00e1torok legfontosabb m\u0171veletei:</p> <ul> <li>\u00e9ppen akt. elem el\u00e9r\u00e9se: <code>operator*()</code>, <code>operator-&gt;()</code></li> <li>k\u00f6vetkez\u0151 elemre l\u00e9p\u00e9s: <code>operator++()</code>, <code>operator++(int)</code></li> <li>iter\u00e1torok (mutat\u00f3k) \u00f6sszehasonl\u00edt\u00e1sa: <code>operator==()</code>, <code>operator!=()</code></li> <li>Kollekci\u00f3 m\u0171velete: mutat\u00f3objektum l\u00e9trehoz\u00e1sa az els\u0151 elemre: <code>begin()</code> tagf\u00fcggv\u00e9ny</li> <li>Kollekci\u00f3 m\u0171velete: mutat\u00f3obj. l\u00e9trehoz\u00e1sa az utols\u00f3 ut\u00e1ni elemre: <code>end()</code> tagf\u00fcggv\u00e9ny</li> </ul> <p>Most elengedj\u00fck egy kicsit a t\u00f6mb\u00f6ket, \u00e9s megn\u00e9z\u00fcnk egy l\u00e1ncolt lis\u00e1t.</p> <pre><code>template &lt;typename T&gt;\nclass List{\n    struct node{ //bels\u0151 oszt\u00e1ly, List&lt;T&gt;::node\n        T data;\n        node* next;\n    };\n\n    node* m_head;\n    std::size_t m_size;\n\npublic:\n    List() : m_head{nullptr},  m_size(0) {}\n\n    List(const List&amp; other) : m_head(nullptr), m_size(0) {\n        for(const auto&amp; elem : other) {\n            push_back(elem);\n        }\n    }\n\n    ~List() {\n        //...\n    }\n\n    void push_front(const T&amp; data) {\n        //...\n    }\n\n    void push_back(const T&amp; data) {\n        //...\n    }\n\n    std::size_t size() const {\n        return m_size;\n    }\n};\n</code></pre> <p>Ha ezen a list\u00e1n v\u00e9gig szeretn\u00e9nk iter\u00e1lni, akkor az valamilyen ronda <code>-&gt;next</code> \u00e9s <code>==nullptr</code> -el teli k\u00f3dot eredm\u00e9nyezne.</p> <p>Ehelyett k\u00e9sz\u00edthet\u00fcnk egy iter\u00e1tor (bels\u0151) oszt\u00e1lyt, amely az iter\u00e1l\u00e1s l\u00e9p\u00e9seit absztrakt\u00e1lja el. Ahhoz, hogy egy iter\u00e1tor haszn\u00e1lhat\u00f3 legyen legal\u00e1bb sz\u00fcks\u00e9g van valamilyen l\u00e9ptet\u0151 oper\u00e1torra, valamint \u00f6sszehasonl\u00edt\u00f3(== != stb.) oper\u00e1torokra is.</p> <p>Pl.:</p> <p> Futtasd!  <pre><code>template &lt;typename T&gt;\nclass List{\n    struct node{\n        T data;\n        node* next;\n    };\n\npublic:\n    struct iterator{\n        friend class List; \n    private:\n        node* it; //az iter\u00e1tor egy pointer absztrakci\u00f3, azt t\u00e1rolja hogy \u00e9ppen melyik node-ra mutat\n        explicit iterator(node* it) : it(it) {} //priv\u00e1t konstruktor, nem kell hogy a h\u00edv\u00f3 f\u00e9l manu\u00e1lisan csin\u00e1ljon iter\u00e1torokat\n    public:\n        iterator(const iterator&amp; other) : it(other.it) {}\n\n        iterator&amp; operator= (const iterator&amp; other) {\n            it = other.it;\n            return *this;\n        }\n\n        /**\n         * @brief l\u00e9ptet\u0151 preincrement oper\u00e1tor, a current = current-&gt;next m\u0171veletet absztrakt\u00e1lja\n         * @return\n         */\n        iterator&amp; operator++() {\n            it = it-&gt;next;\n            return *this;\n        }\n\n        /**\n         * @brief \u00f6sszehasonl\u00edt\u00f3 oper\u00e1tor FONTOS!\n         * @param other\n         * @return\n         */\n        bool operator==(const iterator&amp; other) const {\n            return it == other.it;\n        }\n\n        /**\n         * @brief \u00f6sszehasonl\u00edt\u00f3 oper\u00e1tor FONTOS(tal\u00e1n a legfontosabb)\n         * @param other\n         * @return\n         */\n        bool operator!=(const iterator&amp; other) const {\n            return  !(it == other.it);\n        }\n\n        /**\n         * @brief dereferencia oper\u00e1tor\n         * @return\n         */\n        T&amp; operator*() {\n            return it-&gt;data;\n        }\n\n        /**\n         * @brief ny\u00edl oper\u00e1tor ha az iter\u00e1toron kereszt\u00fcl k\u00f6zvetlen egy oszt\u00e1ly tagjait akarjuk el\u00e9rni\n         * @return\n         */\n        T* operator-&gt;() {\n            return &amp;(it-&gt;data);\n        }\n    };\n};\n</code></pre></p> <p>Term\u00e9szetesen kellenek tagf\u00fcggv\u00e9nyek, amelyek ennek a list\u00e1nak az iter\u00e1torait adj\u00e1k vissza: <code>begin()</code> : A t\u00e1rol\u00f3 elej\u00e9re mutat\u00f3 iter\u00e1tort ad vissza. <code>end()</code> : A t\u00e1rol\u00f3 v\u00e9ge ut\u00e1ni(\"utols\u00f3 valid elem ut\u00e1ni\") iter\u00e1tort ad vissza, \"szentinel\" iter\u00e1tort. Ez egy lista eset\u00e9ben pl. <code>nullptr</code> -re mutat\u00f3 iter\u00e1tor.</p> <p>Ez a begin-end interf\u00e9sz a C++ nyelv t\u00e1rol\u00f3i k\u00f6zt egys\u00e9ges, \u00e9s k\u00e9s\u0151bb l\u00e1tjuk is, hogy van egy fontos nyelvi elem is, ami erre t\u00e1maszkodik, ez\u00e9rt ezt \u00e9rdemes k\u00f6vetni.</p> <pre><code>//List class-on bel\u00fcl, de nem az iterator-ban\n\npublic:\n    /**\n     * @brief begin tagf\u00fcggv\u00e9ny az iter\u00e1l\u00e1shoz\n     * @return az els\u0151 elemre mutat\u00f3 iter\u00e1tor\n     */\n    iterator begin() {\n        return iterator(m_head);\n    }\n\n    /**\n     * @brief end tagf\u00fcggv\u00e9ny az iter\u00e1l\u00e1shoz\n     * @return az utols\u00f3 \u00e9rv\u00e9nyes elem \"ut\u00e1n\" mutat\u00f3 iter\u00e1tor, \"sentinel\" iter\u00e1tor, mindig null-ra mutat\n     * ebben a lista implement\u00e1ci\u00f3ban\n     */\n    iterator end() {\n        return iterator(nullptr);\n    }\n</code></pre> <p>Iter\u00e1torok haszn\u00e1lata:</p> <pre><code>int main(){\n    List&lt;int&gt; list;\n\n    for(int i = -3; i &lt; 5; ++i){\n        list.push_back(i);\n    }\n\n    for(List&lt;int&gt;::iterator it = list.begin(); it != list.end(); ++it) {\n        std::cout &lt;&lt; *it &lt;&lt; ' ';\n    }\n\n    std::cout &lt;&lt; '\\n';\n    *list.begin() = 5;\n}\n</code></pre> <p>Megjegyz\u00e9s: Az iter\u00e1torok t\u00edpusai nagyon hossz\u00faak is lehetnek, ez\u00e9rt \u00e1ltal\u00e1ban az <code>auto</code> kulcssz\u00f3t szok\u00e1s haszn\u00e1lni. Ez ford\u00edt\u00e1sid\u0151ben levezeti \u00e9s behelyettes\u00edti a helyes t\u00edpust ahol lehet. Pl. <pre><code>List&lt;int&gt;::iterator it = list.begin();\n//helyett\nauto it = list.begin();\n</code></pre> Egy p\u00e9lda egy brut\u00e1l hossz\u00fa t\u00edpusn\u00e9vre, amit senkinek sincs kedve ki\u00edrni (ennek kb. fele az iter\u00e1tor) : </p> <p>A fent l\u00e1tott</p> <p><pre><code>for(List&lt;int&gt;::iterator it = list.begin(); it != list.end(); ++it) {\n        std::cout &lt;&lt; *it &lt;&lt; ' ';\n}\n</code></pre> k\u00f3dr\u00e9szlet olyan gyakori, hogy k\u00fcl\u00f6n szintaxis l\u00e9tezik r\u00e1:</p> <pre><code>for(const int&amp; elem : list) { //ua. mint az el\u0151bb, csak konstans referenci\u00e1val\n        std::cout &lt;&lt; elem &lt;&lt; ' ';\n}\n</code></pre> <p>Note</p> <p><code>List&lt;int&gt;::iterator</code> helyett gyakorlatban sokszor helyett <code>auto</code> -t haszn\u00e1lunk: <pre><code>    for(const auto&amp; elem : list) { \n            std::cout &lt;&lt; elem &lt;&lt; ' ';\n    }\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/11-iteratorok/#iteratorok-konstans-tarolokhoz","title":"Iter\u00e1torok konstans t\u00e1rol\u00f3khoz","text":"<p>Konstans t\u00e1rol\u00f3khoz sz\u00fcks\u00e9g van egy \u00faj oszt\u00e1lyra, ami konstans mutat\u00f3k\u00e9nt m\u0171k\u00f6dik. </p> <p>Note</p> <p>Ehhez nem el\u00e9g annyi, hogy a <code>const iterator</code> -t haszn\u00e1lunk! Nem az iter\u00e1tor konstans, hanem a m\u00f6g\u00f6tte l\u00e9v\u0151 t\u00e1rol\u00f3.</p> <p>A konstans iter\u00e1tor konstans elemre mutat, rajta kereszt\u00fcl nem v\u00e1ltoztathat\u00f3 meg az elem.</p> <pre><code>struct const_iterator{\n    friend class List; \nprivate:\n    const node* it; \n    explicit const_iterator(node* it) : it(it) {}\npublic:\n    const_iterator(const const_iterator&amp; other) : it(other.it) {}\n    const_iterator(const iterator&amp; other) : it(other.it) {} // iter\u00e1torb\u00f3l lehet const_iter\u00e1tort\n\n    const_iterator&amp; operator=(const const_iterator&amp; other) {\n        it = other.it;\n        return *this;\n    }\n\n    const_iterator&amp; operator++() {\n        it = it-&gt;next;\n        return *this;\n    }\n\n    bool operator==(const const_iterator&amp; other) const {\n        return it == other.it;\n    }\n\n    bool operator!=(const const_iterator&amp; other) const {\n        return  !(it == other.it);\n    }\n\n    const T&amp; operator*() const {\n        return it-&gt;data;\n    }\n\n    const T* operator-&gt;() const {\n        return &amp;(it-&gt;data);\n    }\n}; \n\nA list\u00e1ban pedig k\u00e9sz\u00edt\u00fcnk `const` overloadot a `begin()` \u00e9s `end()` tagf\u00fcggv\u00e9nyekre, valamint csin\u00e1lunk \u00faj `cbegin()` \u00e9s `cend()` f\u00fcggv\u00e9nyeket:\n\n```cpp\nconst_iterator begin() const {\n    return const_iterator(head);\n}\n\nconst_iterator end() const {\n    return const_iterator(nullptr);\n}\n\nconst_iterator cbegin() const {\n    return begin(); //mivel cbegin() const, a begin() tagfgv. const v\u00e1ltozata v\u00e1laszt\u00f3dik ki\n}\n\nconst_iterator cend() const {\n    return end();\n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/11-iteratorok/#iteratorok-tombok-es-pointerek","title":"Iter\u00e1torok, t\u00f6mb\u00f6k \u00e9s pointerek","text":"<p>Egy t\u00f6mb egy elem\u00e9re mutat\u00f3 pointer kiel\u00e9g\u00edti az iter\u00e1torok legm\u00e9lyebb k\u00f6vetelm\u00e9ny\u00e9t, a LegacyContiguousIterator k\u00f6vetelm\u00e9nyt. </p> <p>Ha belegondolunk, a pointereken m\u0171k\u00f6dnek a +, +=, ++, ==, !=, stb. oper\u00e1torok, valamint ezek val\u00f3ban a t\u00e1rol\u00f3 elemei k\u00f6zti l\u00e9p\u00e9seket val\u00f3s\u00edtj\u00e1k meg. Ez azt jelenti, hogy egy dinamikus t\u00f6mbn\u00e9l p\u00e9ld\u00e1ul nincs sz\u00fcks\u00e9g k\u00fcl\u00f6n iter\u00e1tor oszt\u00e1lyra, hiszen el\u00e9g a pointereket l\u00e9ptetni \u00e9s \u00f6sszehasonl\u00edtani.</p> <p>Ez azt jelenti, hogy egy dinamikus t\u00f6mb\u00f6t el\u00e9g ennyivel kieg\u00e9sz\u00edteni: <pre><code>    T* begin() {\n        return tomb;\n    }\n\n    const T* begin() const { // const T* konstans elemre mutat teh\u00e1t const_iterator sem kell\n        return tomb;\n    }\n\n    T* end() {\n        return tomb + meret;\n    }\n\n    const T* end() const {\n        return tomb + meret;\n    }\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/11-iteratorok/#kiegeszites-iteratorok-besorolasa","title":"Kieg\u00e9sz\u00edt\u00e9s: Iter\u00e1torok besorol\u00e1sa","text":"<p>Az iter\u00e1torokat besorolhatjuk az alapj\u00e1n, hogy mire k\u00e9pesek. Ezeket a csoportokat nem kell tudni, csak \u00e9rdekess\u00e9gk\u00e9pp szerepelnek a jegyzetben:</p> <p></p>"},{"location":"T%C3%B6rzsanyag/12-predik%C3%A1tumok-funktorok/","title":"Predik\u00e1tumok","text":"<p>Van, hogy egy f\u00fcggv\u00e9nyt szeretn\u00e9nk param\u00e9terk\u00e9nt \u00e1tvenni.</p> <p>Pl. \u00edrjunk f\u00fcggv\u00e9nyt, amely egy m\u00e1sik, predik\u00e1tumf\u00fcggv\u00e9ny alapj\u00e1n megkeres egy elemet egy t\u00f6mbben \u00e9s visszaadja az index\u00e9t, vagy a t\u00f6mb m\u00e9ret\u00e9t(az els\u0151 \"invalid\" elem index\u00e9t) ha nincs benne.</p> <p>A predik\u00e1tumf\u00fcggv\u00e9ny t\u00edpus\u00e1t ak\u00e1r ki is \u00edrhatn\u00e1nk, de az cs\u00fany\u00e1n n\u00e9zne ki: <code>bool(*)(const T&amp;)</code>, vagy valami hasonl\u00f3 sz\u00f6rnyeteg, \u00fagyhogy ink\u00e1bb template param\u00e9terk\u00e9nt \u00e1tvessz\u00fck ezt a t\u00edpust is, a ford\u00edt\u00f3 \u00fagyis levezeti a f\u00fcggv\u00e9nyparam\u00e9terb\u0151l.</p> <p> Futtasd!  <pre><code>#include &lt;iostream&gt;\n#include &lt;array&gt;\n\ntemplate&lt;typename T, std::size_t N, typename P&gt;\nstd::size_t find_elem(const std::array&lt;T, N&gt;&amp; a, P predicate){\n    for(std::size_t i = 0; i &lt; a.size(); ++i){\n        if(predicate(a[i])){\n            return i;\n        }\n    }\n    return a.size();\n}\n\n//egy p\u00e9lda predik\u00e1tumf\u00fcggv\u00e9ny:\n\ntemplate&lt;typename T&gt;\nbool isDivisibleBy2(const T&amp; x){\n    return x % 2 == 0;\n}\n\nint main(){\n    std::array&lt;int, 4&gt; arr = {1, 3, 4, 5};\n    std::cout &lt;&lt; find_elem(arr, isDivisibleBy2&lt;int&gt;);\n}\n</code></pre></p> <p>Mint l\u00e1tjuk, a <code>P</code> sablonparam\u00e9tert val\u00f3ban nem kell k\u00e9zzel megadni, azt a ford\u00edt\u00f3 a kapott predik\u00e1tumf\u00fcggv\u00e9nyb\u0151l levezeti.</p>"},{"location":"T%C3%B6rzsanyag/12-predik%C3%A1tumok-funktorok/#nem-csak-fuggvenyek","title":"Nem csak f\u00fcggv\u00e9nyek...","text":"<p>A fenti p\u00e9ld\u00e1ban a <code>P</code> t\u00edpus hely\u00e9re minden olyan t\u00edpus beilleszthet\u0151, amely <code>bool</code> -t(vagy <code>bool</code>-ra implicit konvert\u00e1lhat\u00f3 t\u00edpust) ad vissza \u00e9s egy <code>const T&amp;</code> -et vesz \u00e1t param\u00e9terk\u00e9nt. Az a k\u00e9rd\u00e9s, hogy csak f\u00fcggv\u00e9nyek el\u00e9g\u00edthetik -e ki ezt a k\u00f6vetelm\u00e9nyt.</p> <p>Nos a v\u00e1lasz erre az, hogy nem, ugyanis a f\u00fcggv\u00e9nyh\u00edv\u00e1s oper\u00e1tor t\u00falt\u00f6lthet\u0151. Azokat az oszt\u00e1lyokat amelyeknek van f\u00fcggv\u00e9nyh\u00edv\u00f3 oper\u00e1tora funktornak nevezz\u00fck.</p> <p>A funktorok hasznosak, ha iter\u00e1l\u00e1s alatt valamilyen generikus f\u00fcggv\u00e9nynek kell h\u00edvhat\u00f3 objektumot \u00e1tadni, azonban valamilyen \u00e1llapotot (state) is szeretn\u00e9nk nyilv\u00e1ntartani.</p> <p>Pl. itt egy funktor, amelynek hab\u00e1r sok mindent nem csin\u00e1l, p\u00e9ld\u00e1nak j\u00f3 lesz...</p> <p> Futtasd!  <pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n\nstruct foo{\n    foo() : x(0) {}\n\n    void operator()(const std::string&amp; str = \"\") {\n        std::cout &lt;&lt; \"hello from foo, i've been called: \" &lt;&lt; x &lt;&lt; \" times before! You have said:\" &lt;&lt; str &lt;&lt; '\\n';\n        x++;\n    }\n\n    private:\n        int x;\n};\n\nint main(){\n    foo f;\n    f(\"hello!\");\n    f();\n    f(\"bar\");\n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/13-STL/","title":"A C++ Standard Library","text":"<p>A C++ Standard Library(gyakran STL, stdlib, stb.) alatt \u00e1ltal\u00e1ban a C++ standard \u00e1ltal meghat\u00e1rozott, C++ nyelvhez tartoz\u00f3 szabv\u00e1nyos k\u00f6nyvt\u00e1r egy implement\u00e1ci\u00f3j\u00e1t \u00e9rtj\u00fck (pl libc++, libstdc++, MSVC STL).</p>"},{"location":"T%C3%B6rzsanyag/13-STL/#stl-tarolok","title":"STL T\u00e1rol\u00f3k","text":"<p>A standard t\u00e1rol\u00f3k fontosabb k\u00f6z\u00f6s tulajdons\u00e1gai: </p> <ul> <li>mind oszt\u00e1lysablonok (Standard Template Library)</li> <li><code>begin</code> \u00e9s <code>end</code> iter\u00e1tort visszaad\u00f3 tagf\u00fcggv\u00e9nyek foreach ciklushoz</li> <li><code>at()</code> tagf\u00fcggv\u00e9ny (ahol \u00e9rtelmes)</li> <li>indexel\u0151 oper\u00e1tor (ahol \u00e9rtelmes)</li> </ul>"},{"location":"T%C3%B6rzsanyag/13-STL/#stdstring","title":"std::string","text":"<p><code>&lt;string&gt;</code> header</p> <p>Egy egyszer\u0171 karakterl\u00e1nc implement\u00e1ci\u00f3.</p> <pre><code>std::string str = \"foo\";\n\nstr.push_back(\"bar\");\nstr[0] = 'l';\n\nstd::cout &lt;&lt; str;\n</code></pre>"},{"location":"T%C3%B6rzsanyag/13-STL/#stdvector","title":"std::vector","text":"<p><code>&lt;vector&gt;</code> header</p> <p>Egy \u00e1ltal\u00e1nos dinamikus t\u00f6mb t\u00edpus. Nem mindig akkora helyet foglal, amennyire sz\u00fcks\u00e9ge van, hanem kapacit\u00e1s hi\u00e1ny\u00e1ban geometrikusan n\u00f6veli a lefoglalt mem\u00f3ria m\u00e9ret\u00e9t(pl k\u00e9tszerezi, vagy m\u00e1sf\u00e9lszerezi)</p> <pre><code>std::vector&lt;int&gt; x = {1, 2, 3};\n\nx.push_back(-5);\n\nstd::cout &lt;&lt; *x.begin() &lt;&lt; '\\n';\n\nfor(int elem : x){\n    std::cout &lt;&lt; elem &lt;&lt; ' ';\n}\n</code></pre> <p>Az <code>at()</code> tagf\u00fcggv\u00e9ny kiv\u00e9telt dob, ha t\u00falindexelj\u00fck a t\u00e1rol\u00f3t, az indexel\u0151 oper\u00e1tor viszont nem.</p>"},{"location":"T%C3%B6rzsanyag/13-STL/#fontosabb-konstruktorok","title":"Fontosabb konstruktorok","text":"<p>Van egy konstruktora, amely egyetlen pozit\u00edv eg\u00e9szet vesz \u00e1t, ezzel el\u0151re foglalhat\u00f3 valamennyi elem. Az el\u0151re foglalt elemek el\u0151re default-constructolva lesznek.</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main(){\n    std::vector&lt;int&gt; v(10);\n    std::cout &lt;&lt; v.size();\n}\n</code></pre> <p>Van egy konstruktora, ami listak\u00e9nt \u00e1tveszi, hogy milyen elemek legyenek a vektorban:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main(){\n    std::vector&lt;int&gt; v1({1, 2, 3, 4});\n    std::vector&lt;int&gt; v2 = {5, 6, 7, 8};\n}\n</code></pre> <p>Van egy konstruktora, ami k\u00e9t iter\u00e1tort vesz \u00e1t, ezek k\u00f6zti \u00e9rt\u00e9keket teszi a vektorba:</p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nint main(){\n    std::vector&lt;int&gt; v1({1, 2, 3, 4});\n    std::vector&lt;int&gt; v2(v1.begin(), v1.begin() + 2); // 0. \u00e9s 1. elemet (1, 2) teszi bele, az iterator range-k jobbr\u00f3l nyitottak\n}\n</code></pre> <p>Note</p> <p>Az ilyen iter\u00e1tor p\u00e1rokat gyakran range-nek nevezz\u00fck. Az iter\u00e1tor rangek \u00e1ltal\u00e1ban balr\u00f3l z\u00e1rtak, jobbr\u00f3l nyitottak.</p>"},{"location":"T%C3%B6rzsanyag/13-STL/#stdmap-es-stdunordered_map","title":"std::map \u00e9s std::unordered_map","text":"<p><code>&lt;map&gt;</code> \u00e9s <code>&lt;unordered_map&gt;</code> headerek</p> <p>A <code>map</code> \u00e9s <code>unordered_map</code> kulcs-\u00e9rt\u00e9k p\u00e1rok t\u00e1rol\u00e1s\u00e1ra val\u00f3 t\u00e1rol\u00f3k. A <code>map</code> garant\u00e1lt olvas\u00e1si sorrendet k\u00edn\u00e1l, m\u00edg az <code>unordered_map</code> nem, cser\u00e9be viszont gyorsabb.</p> <p>Mindk\u00e9t t\u00edpus indexel\u0151 oper\u00e1tora beilleszti az adott kulcs-\u00e9rt\u00e9k p\u00e1rt, ha az adott kulcs m\u00e9g nincs a t\u00e1rol\u00f3ban, ha pedig bent van, akkor megv\u00e1ltoztatja a hozz\u00e1 tartoz\u00f3 \u00e9rt\u00e9ket.</p> <pre><code>std::map&lt;std::string, int&gt; m;\n\nm[\"foo\"] = 5;\nm[\"foo\"] = 1;\nstd::cout &lt;&lt; m[\"foo\"];\n</code></pre> <p>Az <code>at()</code> tagf\u00fcggv\u00e9ny nem \u00edgy viselkedik, hanem kiv\u00e9telt dob, ha a kulcs nincs a t\u00e1rol\u00f3ban.</p> <p>Azt, hogy egy kulcs a t\u00e1rol\u00f3ban van -e, a <code>contains(key)</code> tagf\u00fcggv\u00e9nnyel ellen\u0151rizhetj\u00fck.</p>"},{"location":"T%C3%B6rzsanyag/13-STL/#stl-algoritmusok","title":"STL algoritmusok","text":"<p><code>&lt;algorithm&gt;</code> header</p> <p>Az STL algoritmusok k\u00fcl\u00f6nb\u00f6z\u0151 t\u00edpus\u00fa param\u00e9terei:</p> <ul> <li><code>InputIterator</code> : input iter\u00e1tor, olvasni lehet amire mutat \u00e9s el\u0151re l\u00e9ptethet\u0151</li> <li><code>OutputIterator</code> : output iter\u00e1tor, \u00edrni lehet amire mutat \u00e9s el\u0151re l\u00e9ptethet\u0151</li> <li><code>ForwardIterator</code> : olyan iter\u00e1tor, amely ak\u00e1r egyszerre t\u00f6bb l\u00e9p\u00e9ssel is el\u0151re l\u00e9ptethet\u0151(Forward) </li> <li><code>BidirectionalIterator</code> : k\u00e9tir\u00e1ny\u00fa(bidirectional) iter\u00e1tor, mindk\u00e9t ir\u00e1nyba l\u00e9ptethet\u0151, el\u0151re t\u00f6bb l\u00e9p\u00e9sben is</li> <li><code>RandomAccessIterator</code> : Random Access iter\u00e1tor, konstans id\u0151ben l\u00e9ptethet\u0151 minden ir\u00e1nyban ak\u00e1rmekkora l\u00e9p\u00e9sben, kivonhat\u00f3k egym\u00e1sb\u00f3l, pl. pointer t\u00f6mbelemre, vektor iter\u00e1tora</li> <li><code>Predicate</code> : egy operandus\u00fa predik\u00e1tum</li> <li><code>BinaryPredicate</code> : k\u00e9t operandus\u00fa predik\u00e1tum</li> <li><code>UnaryOperation</code>: egy operandus\u00fa m\u0171velet</li> <li><code>Compare</code>: \u00f6sszehasonl\u00edt\u00f3 m\u0171velet, olyan bin\u00e1ris predik\u00e1tum amely elemek sorrendj\u00e9t hat\u00e1rozza meg</li> </ul> <p>Ezeket a nevek tal\u00e1lhat\u00f3k a t\u00e1rgyhoz tartoz\u00f3 STL pusk\u00e1n is, de fejb\u0151l nem k\u00f6telez\u0151 tudni \u0151ket. \u00c9rdemes viszont \u00e1tgondolni, mikor mi\u00e9rt az adott t\u00edpus\u00fa param\u00e9terre van sz\u00fcks\u00e9g.</p>"},{"location":"T%C3%B6rzsanyag/13-STL/#stddistance","title":"std::distance","text":"<p>Megadja k\u00e9t <code>RandomAccessIterator</code> t\u00e1vols\u00e1g\u00e1t.</p> <p><pre><code>std::vector&lt;int&gt; v{3, 1, 4};\nstd::cout &lt;&lt; \"distance(first, last) = \" &lt;&lt; std::distance(v.begin(), v.end()) &lt;&lt; '\\n';\n</code></pre> </p>"},{"location":"T%C3%B6rzsanyag/13-STL/#stdfor_each","title":"std::for_each","text":"<p>A legegyszer\u0171bb algoritmus. A k\u00e9t kapott iter\u00e1tor k\u00f6zt iter\u00e1l \u00e9s minden elemre lefuttatja a kapott funktort. Visszat\u00e9r\u00e9si \u00e9rt\u00e9ke a funktor, amit param\u00e9terk\u00e9nt kapott. Pl.</p> <p> Futtasd! </p> <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\ntemplate&lt;typename T, int X&gt;\nclass CountBy{\n    T counter;\n\n    public:\n\n    CountBy(const T&amp; init) : counter(init) {}\n\n    void operator()(const T&amp; t){\n        counter += t * X;\n    }\n\n    const T&amp; get() const {\n        return counter;\n    }\n};\n\nint main(){\n    std::vector&lt;int&gt; v = {1, 2, 3};\n    CountBy&lt;int, 2&gt; counter(0);\n    counter = std::for_each(v.begin(), v.end(), counter); // 1*2 + 2*2 + 3*2 = 12\n    std::cout &lt;&lt; counter.get();\n}\n</code></pre> <p></p>"},{"location":"T%C3%B6rzsanyag/13-STL/#stdfind-stdfind_if","title":"std::find, std::find_if","text":"<p><code>InputIt find(InputIt first, InputIt last, const T&amp; value);</code></p> <p>Az <code>std::find</code> f\u00fcggv\u00e9ny k\u00e9t iter\u00e1tort(a keres\u00e9s dom\u00e9nj\u00e9t), valamint egy \u00e9rt\u00e9ket vesz \u00e1t. A dom\u00e9nj\u00e9ben az <code>==</code> oper\u00e1tor seg\u00edts\u00e9g\u00e9vel keresi a kapott \u00e9rt\u00e9ket, \u00e9s ha megtal\u00e1lja, akkor visszaad r\u00e1 egy iter\u00e1tort. Ha nem tal\u00e1lja meg, akkor a dom\u00e9n v\u00e9g\u00e9re mutat\u00f3 iter\u00e1tort adja vissza.</p> <pre><code>    std::vector&lt;foo&gt; fs = {foo(1), foo(3), foo(-2)};\n\n    auto find_iterator = std::find(fs.begin(), fs.end(), foo(3));\n    if(find_iterator != fs.end()) {\n        std::cout &lt;&lt; \"foo(3) pozicio: \" &lt;&lt; find_iterator - fs.begin() &lt;&lt; '\\n';\n    }else {\n        std::cout &lt;&lt; \"foo(3) -ra nincs talalat\\n\";\n    }\n</code></pre> <p><code>InputIt find_if(InputIt first, InputIt last, UnaryPred p);</code></p> <p>Az <code>std::find_if</code> 3. param\u00e9terk\u00e9nt egy \u00e9rt\u00e9k helyett egy predik\u00e1tumf\u00fcggv\u00e9nyt(vagy m\u00e1s f\u00fcggv\u00e9nyh\u00edv\u00f3 oper\u00e1torral rendelkez\u0151 objektumot) vesz \u00e1t, amely <code>bool</code> -t ad vissza \u00e9s egyetlen param\u00e9terek\u00e9nt \u00e1tveszi egy a dom\u00e9nben t\u00e1rolt objektumok t\u00edpus\u00e1val megegyez\u0151 t\u00edpus\u00fa objektumot(\u00e9rtsd: \u00e1tveszi az \u00e9ppen vizsg\u00e1lt elemet).</p> <pre><code>    auto elter_2_iterator = std::find_if(fs.begin(), fs.end(), isDivisibleBy2);\n    if(elter_2_iterator != fs.end()) {\n        std::cout &lt;&lt; \"foo(%2) pozicio: \" &lt;&lt; elter_2_iterator - fs.begin() &lt;&lt; '\\n';\n    }else {\n        std::cout &lt;&lt; \"foo(%2) -re nincs talalat\\n\";\n    }\n</code></pre> <p></p>"},{"location":"T%C3%B6rzsanyag/13-STL/#stdcount-es-stdcount_if","title":"std::count \u00e9s std::count_if","text":"<p><code>count(InputIt first, InputIt last, const T&amp; value);</code></p> <p><code>count_if(InputIt first, InputIt last, UnaryPred p);</code></p> <p>Ugyan az, mint a <code>find</code> \u00e9s <code>find_if</code>, csak \u00f6sszesz\u00e1molja a felt\u00e9telt kiel\u00e9g\u00edt\u0151 elemeket.</p> <p> Futtasd!  <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nbool divisibleBy2(int x){\n    return x % 2 == 0;\n}\n\nint main(){\n    std::vector&lt;int&gt; v = {3, 2, 1, 5, 3, 2, 8, 3, 12};\n    std::cout &lt;&lt; \"3-asok szama: \" &lt;&lt; std::count(v.begin(), v.end(), 3);\n    std::cout &lt;&lt; \"\\n2-vel oszthatoak szama: \" &lt;&lt; std::count_if(v.begin(), v.end(), divisibleBy2);\n}\n</code></pre></p> <p></p>"},{"location":"T%C3%B6rzsanyag/13-STL/#stdfill-stdgenerate","title":"std::fill, std::generate","text":"<p>Az <code>std::fill</code> felt\u00f6lti a kapott range-t egy adott \u00e9rt\u00e9kkel.</p> <p><code>void fill(ForwardIt first, ForwardIt last, const T&amp; value);</code></p> <p> Futtasd!  <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main(){\n    std::vector&lt;int&gt; v(10); //el\u0151re foglalunk 10 objektumot, k\u00fcl\u00f6nben a range 0 elem\u0171 lenne\n    std::fill(v.begin(), v.end(), 9); \n    for(auto&amp; elem : v){\n        std::cout &lt;&lt; elem &lt;&lt; ' ';\n    }\n}\n</code></pre></p> <p>Az std::generate felt\u00f6lti a kapott range-t \u00e9rt\u00e9kekkel.  Ezt egy gener\u00e1tor seg\u00edts\u00e9g\u00e9vel teszi, amely a harmadik param\u00e9tere. A gener\u00e1tor param\u00e9ter n\u00e9lk\u00fcl h\u00edvhat\u00f3 objektum, amely visszaadja a beillesztend\u0151 \u00e9rt\u00e9ket.</p> <p><code>void generate(ForwardIt first, ForwardIt last, Generator g);</code></p> <p> Futtasd!  <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nstruct generator{\n    int x;\n    generator() : x(0) {}\n\n    int operator()(){\n        return x++; //eml\u00e9kezz\u00fcnk vissza mit csin\u00e1l a posztinkremens oper\u00e1tor(n\u00f6veli, de r\u00e9gi \u00e9rt\u00e9ket return\u00f6l)\n    }\n};\n\nint main(){\n    std::vector&lt;int&gt; v(10); //el\u0151re foglalunk 10 objektumot, k\u00fcl\u00f6nben a range 0 elem\u0171 lenne\n    generator g; //k\u00e9sz\u00edt\u00fcnk egy gener\u00e1tor p\u00e9ld\u00e1nyt\n    std::generate(v.begin(), v.end(), g); //\u00e1tadjuk a gener\u00e1tort\n    for(auto&amp; elem : v){\n        std::cout &lt;&lt; elem &lt;&lt; ' ';\n    }\n}\n</code></pre></p> <p>A gener\u00e1l\u00e1s gyakorlatilag a k\u00f6vetkez\u0151b\u0151l \u00e1ll: <pre><code>for(auto it = v.begin(), it != v.end(), ++it){\n    *it = g();\n}\n</code></pre></p> <p></p>"},{"location":"T%C3%B6rzsanyag/13-STL/#stdtransform","title":"std::transform","text":"<p>Az <code>std::transform</code> v\u00e9grehajt egy f\u00fcggv\u00e9nyt az adott range minden elem\u00e9n \u00e9s \u00e1tm\u00e1solja egy m\u00e1sik rangebe. A f\u00fcggv\u00e9ny a range mindig aktu\u00e1lisan v\u00e1ltoztatand\u00f3 elem\u00e9t veszi \u00e1t. Els\u0151 k\u00e9t param\u00e9tere a dom\u00e9n range eleje \u00e9s v\u00e9ge, a hardmadik param\u00e9tere a m\u00e1sol\u00e1s c\u00e9lj\u00e1nak eleje, a negyedik param\u00e9ter pedig a v\u00e9grehajtand\u00f3 m\u0171velet(f\u00fcggv\u00e9ny vagy funktor).</p> <p><code>OutputIt transform(InputIt first1, InputIt last1, OutputIt d_first, UnaryOp unary_op);</code></p> <p> Futtasd!  <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\ntemplate&lt;typename T&gt; //template hogy mindenf\u00e9le vektorhoz j\u00f3 legyen\nstruct transformer{\n    T elozo;\n\n    transformer() : elozo(0) {}\n\n    T operator()(const T&amp; elem){\n        int eredmeny = elem + elozo;\n        elozo = elem;\n        return eredmeny;\n    }\n};\n\nint main(){\n    std::vector&lt;int&gt; v = {3, 2, 1, 5, 3, 2, 8, 3, 12};\n    std::vector&lt;int&gt; w(v.size());\n    transformer&lt;int&gt; t;\n    std::transform(v.begin(), v.end(), w.begin(), t);\n\n    for(auto&amp; elem : w){\n        std::cout &lt;&lt; elem &lt;&lt; ' ';\n    }\n}\n</code></pre></p> <p></p> K\u00e9t range-s <code>std::transform</code> <p>Az <code>std::transform</code>-nak l\u00e9tezik egy k\u00e9t range-n m\u0171k\u00f6d\u0151 v\u00e1ltozata is:</p> <p><code>OutputIt transform(InputIt1 first1, InputIt1 last1, InputIt2 first2, OutputIt d_first, BinaryOp binary_op);</code></p> <p> Futtasd!  <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main(){\n    std::vector&lt;int&gt; v = {3, 2, 1, 5, 3, 2, 8, 3, 12};\n    std::vector&lt;int&gt; w = {2, 5, 1, 5, 0, 2, 9, 0, 10};\n\n    std::vector&lt;int&gt; x(v.size());\n\n    //std::plus&lt;T&gt; : funktor aminek a fgv.h\u00edv\u00e1s oper\u00e1tora \u00f6sszeadja a k\u00e9t operandust\n    std::transform(v.begin(), v.end(), w.begin(), x.begin(), std::plus&lt;int&gt;()/*default constructed std::plus instance*/);\n    for(int elem : x){\n        std::cout &lt;&lt; elem &lt;&lt; '\\n';\n    }\n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/13-STL/#stdequal-stdmismatch","title":"std::equal, std::mismatch","text":"<p>Az <code>std::equal</code> megmondja, hogy k\u00e9t range minden eleme egyenl\u0151 -e.</p> <p><code>bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2);</code> <code>bool equal(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPred p);</code></p> <p> Futtasd!  <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main(){\n    std::vector&lt;int&gt; v = {3, 2, 1, 5, 3, 2, 8, 3, 12};\n    std::vector&lt;int&gt; w = {1, 4, 3, 2, 1, 7, 8, 9, 14};\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::equal(v.begin(), v.end(), w.begin(), w.end()) &lt;&lt; '\\n';\n    std::cout &lt;&lt; std::boolalpha &lt;&lt; std::equal(v.begin(), v.end(), v.begin(), v.end());\n}\n</code></pre></p> <p>Az <code>std::mismatch</code> megkeresi az els\u0151 olyan pontot k\u00e9t range-ben, ahol elt\u00e9rnek. Els\u0151 h\u00e1rom param\u00e9tere:</p> <ul> <li>Els\u0151 range eleje</li> <li>Els\u0151 range v\u00e9ge</li> <li>M\u00e1sodik range eleje</li> </ul> <p>Opcion\u00e1lis negyedik param\u00e9tere egy predik\u00e1tum, amely ha igazat ad vissza, mismatch-nek sz\u00e1m\u00edt az adott elemp\u00e1r.</p> <p><code>std::pair&lt;InputIt1, InputIt2&gt; mismatch( InputIt1 first1, InputIt1 last1, InputIt2 first2);</code></p> <p><code>std::pair&lt;InputIt1, InputIt2&gt; mismatch(InputIt1 first1, InputIt1 last1, InputIt2 first2, BinaryPred p);</code></p> <p>Visszat\u00e9r\u00e9si \u00e9rt\u00e9ke egy <code>std::pair</code>, amely a k\u00e9t rangen bel\u00fcl a k\u00fcl\u00f6nbs\u00e9gre mutat\u00f3 iter\u00e1torokat tartalmazza.</p> <p> Futtasd!  <pre><code>#include &lt;iostream&gt;\n#include &lt;vector&gt;\n#include &lt;algorithm&gt;\n\nint main(){\n    std::vector&lt;int&gt; v = {3, 2, 1, 5, 3, 2, 8, 3, 12};\n    std::vector&lt;int&gt; w = {3, 2, 1, 5, 0, 2, 8, 0, 12};\n\n    auto it_pair = std::mismatch(v.begin(), v.end(), w.begin());\n    std::cout &lt;&lt; \"Mismatch at: \" &lt;&lt; it_pair.first - v.begin();\n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/2-standard-io/","title":"Standard IO","text":""},{"location":"T%C3%B6rzsanyag/2-standard-io/#problemak-a-c-standard-io-val","title":"Probl\u00e9m\u00e1k a C standard IO-val","text":"<p>A <code>printf</code> \u00e9s <code>scanf</code> f\u0151 probl\u00e9m\u00e1ja a compile time hibaellen\u0151rz\u00e9s hi\u00e1nya. Nincs t\u00edpusellen\u0151rz\u00e9s, \u00edgy gyakran lesznek ezekkel a f\u00fcggv\u00e9nyekkel kapcsolatban probl\u00e9m\u00e1ink. A <code>scanf</code> f\u00fcggv\u00e9nyn\u00e9l ezen fel\u00fcl nem szabad elfelejteni a c\u00edmk\u00e9pz\u0151 oper\u00e1tort (<code>&amp;</code>) sem, a <code>printf</code> pedig nem k\u00e9pes ki\u00edrni a saj\u00e1t t\u00edpusainkat, valamint ezt megtan\u00edtani sem tudjuk neki.</p>"},{"location":"T%C3%B6rzsanyag/2-standard-io/#c-alternativak","title":"C++ alternat\u00edv\u00e1k","text":"<p>https://en.cppreference.com/w/cpp/io/cout</p> <p>https://en.cppreference.com/w/cpp/io/cin</p> <p><code>&lt;iostream&gt;</code> header</p> <p>C++ban a standard input \u00e9s output k\u00e9t f\u0151 glob\u00e1lis objektum (<code>std::cin</code> \u00e9s <code>std::cout</code>) \u00e9s a C-b\u0151l shiftel\u0151 oper\u00e1torokk\u00e9nt, (<code>&gt;&gt;</code> \u00e9s <code>&lt;&lt;</code>) ismert szimb\u00f3lumokkal lett megoldva. A standard IO haszn\u00e1lat\u00e1hoz az <code>iostream</code> headerre van sz\u00fcks\u00e9g.</p> <p>Ha egy v\u00e1ltoz\u00f3ba szeretn\u00e9nk beolvasni, majd ezt ki\u00edrni: <pre><code>#include &lt;iostream&gt;\n\nint main(){\n    int x;\n    std::cin &gt;&gt; x;\n    std::cout &lt;&lt; x;\n}\n</code></pre></p> <p>A beolvas\u00e1sokat \u00e9s ki\u00edr\u00e1sokat l\u00e1ncolhatjuk is:</p> <p><pre><code>int x;\ndouble d;\nchar c;\n\nstd::cin &gt;&gt; x &gt;&gt; d &gt;&gt; c;\nstd::cout &lt;&lt; \"int: \" &lt;&lt; x &lt;&lt; \" double: \" &lt;&lt; d &lt;&lt; \" char: \" &lt;&lt; c;\n</code></pre> Ez a \"szintaktika\" oper\u00e1torok t\u00falt\u00f6lt\u00e9s\u00e9n (overload) alapul. Jelenleg annyi eml\u00edtest teszek ezzel kapcsolatban, hogy val\u00f3j\u00e1ban egy <code>operator&lt;&lt;</code> f\u00fcggv\u00e9nyt h\u00edvunk meg az <code>std::cout</code> (referencia r\u00e1) \u00e9s a \"ki\u00edrand\u00f3 dolog\" param\u00e9terekkel, ami azt\u00e1n referenciak\u00e9nt \u00fajra visszaadja az <code>std::cout</code> -ot, \u00edgy tudjuk \u0151ket l\u00e1ncolni is. K\u00e9s\u0151bb azt is megtanuljuk, hogy pontosan hogyan m\u0171k\u00f6dik az oper\u00e1torok overload-ol\u00e1sa \u00e9s l\u00e1ncol\u00e1sa, valamint megtan\u00edtjuk majd a saj\u00e1t t\u00edpusaink beolvas\u00e1s\u00e1t \u00e9s ki\u00edr\u00e1s\u00e1t is.</p>"},{"location":"T%C3%B6rzsanyag/2-standard-io/#get","title":"Get","text":"<p>https://en.cppreference.com/w/cpp/io/basic_istream/get</p> <pre><code>char k = std::cin.get(); //bek\u00e9r\u00fcnk 1 karaktert\n\nchar k2;\nstd::cin.get(k2); //ugyanaz mint az el\u0151z\u0151, csak m\u00e1shogy, itt out parameter van return helyett\n\nchar k3[6];\nstd::cin.get(k3, 5); //5 karaktert olvasunk egy 5 m\u00e9ret\u0171 t\u00f6mbbe. Ez a f\u00fcggv\u00e9ny tesz lez\u00e1r\u00f3 0-t\n</code></pre>"},{"location":"T%C3%B6rzsanyag/2-standard-io/#stdgetline","title":"std::getline","text":"<p>https://en.cppreference.com/w/cpp/string/basic_string/getline</p> <p>Az std::getline f\u00fcggv\u00e9ny alap\u00e9rtelmezetten egy eg\u00e9sz sort olvas be egy input streamr\u0151l, viszont saj\u00e1t elv\u00e1laszt\u00f3t is megadhatunk neki.</p> <pre><code>std::string line;\nstd::getline(std::cin, line);\nstd::getline(std::cin, line, ','); // ',' karakterig olvasunk\n</code></pre>"},{"location":"T%C3%B6rzsanyag/2-standard-io/#ignore","title":"Ignore","text":"<p>https://en.cppreference.com/w/cpp/io/basic_istream/ignore</p> <p>A bemeneti streameknek van egy <code>ignore</code> tagf\u00fcggv\u00e9nye, amellyel eldobhatunk(\"ignor\u00e1lhatunk\") karaktereket. <pre><code>std::cin.ignore(x); // x karaktert ignor\u00e1l, vagy am\u00edg eof-t nem kap\nstd::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max()); //ignor\u00e1l mindent ami a bemeneten van\nstd::cin.ignore(x, c); //ignor\u00e1l x karakter, vagy am\u00edg nem kap c-vel azonos karaktert\n</code></pre></p> <p><code>std::numeric_limits&lt;T&gt;::max()</code> : adott <code>T</code> numerikus t\u00edpus maximum \u00e9rt\u00e9k\u00e9t adja vissza. (pl. <code>std::numeric_limits&lt;std::size_t&gt;::max()</code>)</p> <p>Pl: <pre><code>#include &lt;iostream&gt;\n#include &lt;limits&gt;\n\nint main(){\n    int a;\n    int b;\n    std::cin &gt;&gt; a;\n    std::cin.ignore(5);\n    std::cin &gt;&gt; b;\n    std::cout &lt;&lt; \"a: \" &lt;&lt; a &lt;&lt; \" b: \" &lt;&lt; b &lt;&lt; '\\n';\n\n    char c1;\n    char c2;\n    std::cin &gt;&gt; c1;\n    //ignor\u00e1lunk addig am\u00edg ';' -t nem kapunk. Ignor\u00e1lja a ; -t is!\n    std::cin.ignore(std::numeric_limits&lt;std::streamsize&gt;::max(), ';'); \n    std::cin &gt;&gt; c2;\n    std::cout &lt;&lt; \"c1: '\" &lt;&lt; c1 &lt;&lt;\"' c2: '\" &lt;&lt; c2 &lt;&lt; \"'\\n\";\n}\n</code></pre> </p> <p>Nem \u00f6sszekeverend\u0151 a teljesen m\u00e1s jelent\u00e9s\u0171 <code>std::ignore</code>-al.</p>"},{"location":"T%C3%B6rzsanyag/2-standard-io/#file-io","title":"File IO","text":"<p><code>&lt;fstream&gt;</code> header</p> <p>C++ -ban a file IO API-ja (az, amit a programoz\u00f3 l\u00e1t bel\u0151le, Application Programming Interface) megegyezik a standard IO-val.</p> <p>File olvas\u00e1sra megnyit\u00e1s\u00e1hoz  \u00e9s nyilv\u00e1ntart\u00e1s\u00e1hoz az <code>std::ifstream</code> (Input Filestream) t\u00edpust, \u00edr\u00e1sra az <code>std::ofstream</code> (Output Filestream) t\u00edpust haszn\u00e1ljuk.</p> <pre><code>#include &lt;fstream&gt;\n\nint main(){\n    std::ifstream input(\"input.txt\");\n    int x;\n    input &gt;&gt; x; \n    std::ofstream output(\"output.txt\");\n    output &lt;&lt; x;\n}\n</code></pre> <p>Az <code>std::ifstream</code> \u00e9s <code>std::ofstream</code> t\u00edpus\u00f3 objektumok automatikusan (ld. oszt\u00e1lyok) bez\u00e1rj\u00e1k a fileokat, ha scopeon k\u00edv\u00fcl ker\u00fclnek, \u00edgy nem sz\u00fcks\u00e9ges a fileokat manu\u00e1lisan bez\u00e1rni, viszont a lehet\u0151s\u00e9g\u00fcnk megvan r\u00e1. (<code>.close()</code>)</p>"},{"location":"T%C3%B6rzsanyag/2-standard-io/#io-manipulatorok","title":"IO manipul\u00e1torok","text":"<p><code>&lt;ios&gt;</code> \u00e9s <code>&lt;iomanip&gt;</code> headerek</p> <p>Az IO m\u0171veletek viselkes\u00e9s\u00e9t \u00fan. manipul\u00e1torok seg\u00edts\u00e9g\u00e9vel v\u00e1ltoztathatjuk meg. Ezeket \u00fagy haszn\u00e1ljuk, mintha \u0151k maguk is input/output lenn\u00e9nek. Pl. ha az eg\u00e9szeket mindenk\u00e9pp 7 sz\u00e1mjeggyel szeretn\u00e9nk ki\u00edrni, \u00e9s 0-val kit\u00f6lteni a marad\u00e9k helyet.</p> <p> Futtasd!  <pre><code>#include &lt;iomanip&gt;\n#include &lt;iostream&gt;\n\nint main(){\n    int x = 356;\n    std::cout &lt;&lt; std::setw(7) &lt;&lt; std::setfill('0') &lt;&lt; x; \n}\n</code></pre></p> <p>A manipul\u00e1torok hat\u00f3k\u00f6re v\u00e1ltoz\u00f3, vannak olyanok, amelyek csak a k\u00f6vetkez\u0151 outputra hatnak, de vannak olyanok is, amelyek hat\u00e1sa \"v\u00e9gtelen\"(am\u00edg meg nem v\u00e1ltoztatjuk).</p> <p>Fontosabb mainpul\u00e1torok:</p> <ul> <li><code>std::setw(size)</code> : megadja, hogy a sz\u00e1mok h\u00e1ny karakter sz\u00e9lesek legyene</li> <li><code>std::setfill(ch)</code> : a param\u00e9terk\u00e9nt kapott karakterrel lesz kit\u00f6ltve a marad\u00e9k hely, ha egy ki\u00edrt \u00e9rt\u00e9k nem t\u00f6lti ki a megadott sz\u00e9less\u00e9get</li> <li><code>std::setprecision(p)</code> : a lebeg\u0151pontos sz\u00e1mok tizedesjegyeinek pontoss\u00e1g\u00e1t (sz\u00e1m\u00e1t) \u00e1ll\u00edtja be</li> <li><code>std::oct</code>, <code>std::dec</code>, <code>std::hex</code> : 8-as, 10-es \u00e9s 16-os sz\u00e1mrenszerre \u00e1ll\u00edtja az adott streamet</li> <li><code>std::skipws</code>, <code>std::noskipws</code> : Be/kikapcsolja a leading whitespace \u00e1tugr\u00e1s\u00e1t</li> <li><code>std::boolalpha</code>, <code>std::noboolalpha</code> : Be/kikapcsolja a <code>bool</code> \u00e9rt\u00e9kek alfanumerikus megjelen\u00edt\u00e9s\u00e9t. (be: <code>true</code>/<code>false</code>, ki: <code>1</code>/<code>0</code>)</li> </ul> <p>T\u00f6bb IO manipul\u00e1tor \u00e9s egy\u00e9b kapcsol\u00f3d\u00f3 foszl\u00e1nyok itt: https://en.cppreference.com/w/cpp/io/manip</p> <p>Sokszor \u00e1ll\u00edtunk el dolgokat egy IO streamen, viszont nem szeretn\u00e9nk egyes\u00e9vel vissza\u00e1ll\u00edtani az eredeti \u00e9rt\u00e9keket. Ekkor van k\u00e9t lehet\u0151s\u00e9g\u00fcnk.  Az els\u0151, hogy egy \"buffer stream\" seg\u00edts\u00e9g\u00e9vel \u00f6ssze\u00e1ll\u00edtunk egy stringet \u00e9s ezt a stringet \u00edrjuk ki. Ehhez haszn\u00e1ljuk az <code>std::stringstream</code> t\u00edpust: https://en.cppreference.com/w/cpp/io/basic_stringstream</p> <p> Futtasd! </p> <pre><code>#include &lt;sstream&gt;\n#include &lt;iostream&gt;\n\nint main(){\n    std::stringstream buf;\n    buf &lt;&lt; std::hex &lt;&lt; 45678;\n    std::cout &lt;&lt; buf.str();\n}\n</code></pre> <p>A m\u00e1sik lehet\u0151s\u00e9g az, hogy a stream be\u00e1ll\u00edt\u00e1sait (flag, precision, width) elmentj\u00fck, majd ezeket vissza\u00e1ll\u00edtjuk. Ez el\u00e9g nagy szenved\u00e9s \u00e9s nem \u00e9rdemes csin\u00e1lni, csak ha nagyon musz\u00e1ly.</p> <p> Futtasd!  <pre><code>#include &lt;sstream&gt;\n#include &lt;iostream&gt;\n#include &lt;iomanip&gt;\n\nint main(){\n    //most \u0151szint\u00e9n, kinek van ehhez kedve?\n    std::ios_base::fmtflags flags = std::cout.flags();\n    std::streamsize prec = std::cout.precision();\n    std::streamsize width = std::cout.width();\n    std::cout &lt;&lt; std::hex &lt;&lt; 465643 &lt;&lt; std::setprecision(12) &lt;&lt; std::setw(20) &lt;&lt; 454.3256456436;\n    std::cout.flags(flags);\n    std::cout.precision(prec);\n    std::cout.width(width);\n    std::cout &lt;&lt; '\\n';\n    std::cout &lt;&lt; 54;\n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/3-kivetelek/","title":"Kiv\u00e9telek, hibakezel\u00e9s","text":""},{"location":"T%C3%B6rzsanyag/3-kivetelek/#hibakezeles-c-ben","title":"Hibakezel\u00e9s C-ben","text":"<pre><code>double oszt(double x, double y){\n    if(y == 0){\n        //mit csin\u00e1ljunk? exit, vagy csak \u00edrjunk ki valamit? \n    }else{\n        return x/y;\n    }\n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/3-kivetelek/#c-ban","title":"C++ -ban","text":"<p>https://en.cppreference.com/w/cpp/language/exceptions</p> <p>A C++ egy fontos nyelvi elemei a kiv\u00e9telek (exception). Ezek seg\u00edts\u00e9g\u00e9vel kiv\u00e9teles esetekkor dobhatunk egy \"hib\u00e1t\", amit a program elkaphat. Ez egy megoszt\u00f3 feature a k\u00f6z\u00f6ss\u00e9gben (ld. \"hidden control flow\"), viszont sokszor hasznos lehet. P\u00e9ld\u00e1ul null\u00e1val val\u00f3 oszt\u00e1s eset\u00e9n val\u00f3sz\u00edn\u0171leg nem nek\u00fcnk, hanem a h\u00edv\u00f3 k\u00f3dnak k\u00e9ne kezelnie a hib\u00e1t.</p> <p>Kiv\u00e9telt a <code>throw</code> kulcssz\u00f3val dobhatunk, valamint a <code>try</code> kulcssz\u00f3val nyitott scope-ban dobott kiv\u00e9teleket a <code>catch</code> kulcssz\u00f3val kaphatunk el.</p> <p>Kiv\u00e9telk\u00e9nt b\u00e1rmilyen t\u00edpust dobhatunk (int, const char*, stb.), viszont \u00e9rdemes az <code>std::exception</code> \u00e9s a bel\u0151le lesz\u00e1rmaz\u00f3 (k\u00e9s\u0151bb) t\u00edpus\u00fa objekutmokat dobni. Ezekhez a t\u00edpusokhoz az <code>stdexcept</code> nev\u0171 header-re van sz\u00fcks\u00e9g.</p> <p>https://en.cppreference.com/w/cpp/error/exception</p> <p> Futtasd!  <pre><code>#include &lt;stdexcept&gt;\n#include &lt;iostream&gt;\n\ndouble oszt(double x, double y){\n    if(y == 0){\n        throw std::runtime_error(\"0-val valo osztas!\"); \n        /*\n        lehetne:\n        throw \"0-val valo osztas\";\n        vagy\n        throw 0;\n        stb. viszont ezeket nem sz\u00e9p dobni.\n        */\n    }else{\n        return x/y;\n    }\n}\n\nint main(){\n    try{\n        oszt(5.0, 0.0);\n    }catch(const std::exception&amp; e){ //konstans referenciak\u00e9nt kapjuk el az exception-t(ezt mindig!)\n        std::cout &lt;&lt; e.what(); //.what() : visszaadja az exception \"\u00fczenet\u00e9t\"\n        //egy\u00e9b hibakezel\u0151 k\u00f3d...\n    }\n}\n</code></pre></p> <p>K\u00e9s\u0151bb lesz sz\u00f3 arr\u00f3l, hogy hogyan k\u00e9sz\u00edthet\u00fcnk saj\u00e1t kiv\u00e9tel t\u00edpusokat amelyek az <code>std::exception</code> -b\u0151l sz\u00e1rmaznak.</p>"},{"location":"T%C3%B6rzsanyag/4-dinamikus-memoriakezeles/","title":"Dinamikus mem\u00f3riakezel\u00e9s","text":""},{"location":"T%C3%B6rzsanyag/4-dinamikus-memoriakezeles/#c-dinamikus-memoriakezeles","title":"C dinamikus mem\u00f3riakezel\u00e9s","text":"<p>A C dinamikus mem\u00f3riakezel\u00e9se a k\u0151korszakban j\u00e1r. Megk\u00e9rdezi h\u00e1ny b\u00e1jtnyi mem\u00f3ri\u00e1ra van sz\u00fcks\u00e9g\u00fcnk, majd visszadob r\u00e1 egy pointert.</p>"},{"location":"T%C3%B6rzsanyag/4-dinamikus-memoriakezeles/#c-memoriakezeles","title":"C++ mem\u00f3riakezel\u00e9s","text":"<p>A C++ <code>malloc</code> f\u00fcggv\u00e9ny\u00e9t a <code>new</code> oper\u00e1tor (igen, ezek oper\u00e1torok), a <code>free</code> f\u00fcggv\u00e9nyt pedig a <code>delete</code> \u00e9s <code>delete[]</code> oper\u00e1tor v\u00e1ltotta fel.</p> <p>A <code>new</code> egy intelligens eszk\u00f6z. Nem mem\u00f3riamennyis\u00e9get, hanem egy t\u00edpust \u00e9s opcion\u00e1lisan egy t\u00f6mbm\u00e9retet kap.  Pl. <pre><code>int* x = new int; //egy darab dinamikusan foglalt int\n\nint* tomb = new int[5]; //egy dinamikusan foglalt 5 m\u00e9ret\u0171 t\u00f6mb\n\nstd::size_t tombMeret; //std::size_t : \u00e1ltal\u00e1ban mem\u00f3riafoglal\u00e1sok m\u00e9ret\u00e9t vagy indexeket t\u00e1rol\u00f3 el\u0151jel n\u00e9lk\u00fcli eg\u00e9sz\n\nstd::cin &gt;&gt; tombMeret;\n\nint* dinTomb = new int[tombMeret];\n</code></pre></p> <p>A <code>delete</code> oper\u00e1tor a <code>new</code> oper\u00e1torral lefoglalt mem\u00f3ri\u00e1t szabad\u00edtja fel. Ha t\u00f6mb\u00f6t szabad\u00edtunk fel, akkor a <code>delete[]</code> oper\u00e1tort kell haszn\u00e1lni.</p> <p>Az el\u0151bbi p\u00e9lda foglal\u00e1sok felszabad\u00edt\u00e1sa: <pre><code>delete x;\ndelete[] tomb;\ndelete[] dinTomb;\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/4-dinamikus-memoriakezeles/#variable-length-array","title":"Variable Length Array","text":"<p>Az al\u00e1bbi k\u00f3dr\u00e9szlet az ISO C++ Standard szerint nem szabv\u00e1nyos C++, a GCC \u00e9s Clang ford\u00edt\u00f3k compiler extensionk\u00e9nt enged\u00e9lyezik. VLA-t ne haszn\u00e1ljunk, hiszen \u00edgy a stacken sz\u00fcks\u00e9ges mem\u00f3ria m\u00e9rete ismeretlen lesz.</p> <p> Futtasd! </p> <pre><code>int x;\nstd::cin &gt;&gt; x;\nint a[x];\n</code></pre> <p>A non-standard extension-\u00f6k kikapcsol\u00e1sa:</p> <ul> <li>GCC/Clang: <code>-pedantic-errors</code> flag</li> <li>MSVC: <code>/permissive-</code> flag</li> </ul>"},{"location":"T%C3%B6rzsanyag/5-operator_no_class/","title":"Operator overloading - Oszt\u00e1lyok n\u00e9lk\u00fcl","text":""},{"location":"T%C3%B6rzsanyag/5-operator_no_class/#mik-az-operatorok-valojaban","title":"Mik az oper\u00e1torok val\u00f3j\u00e1ban?","text":"<p>Az oper\u00e1torok val\u00f3j\u00e1ban csak speci\u00e1lis f\u00fcggv\u00e9nyek. Ez azt jelenti, hogy ugyan\u00fagy b\u00e1nhatunk vel\u00fck, hab\u00e1r van n\u00e9mi megk\u00f6t\u00e9s, azonban legt\u00f6bbsz\u00f6r ezek nem fognak az utunkban \u00e1llni. </p> <p>Az oper\u00e1torokra f\u00fcggv\u00e9nyk\u00e9nt hivatkozhatunk, t\u00falt\u00f6lt\u00e9s\u00fck \"szintaxisa\" is ezen alapszik. pl. <code>+</code> oper\u00e1tor: <code>operator+</code>.</p>"},{"location":"T%C3%B6rzsanyag/5-operator_no_class/#egyszeru-operator-pelda","title":"Egyszer\u0171 oper\u00e1tor p\u00e9lda","text":"<p>Hozzunk l\u00e9tre egy komplex sz\u00e1mot modellez\u0151 strukt\u00far\u00e1t: <pre><code>struct Komplex{\n    double re, im;\n};\n</code></pre></p> <p>K\u00e9t komplex sz\u00e1mot szeretn\u00e9nk a <code>+</code> oper\u00e1torral \u00f6sszeadni, majd az eredm\u00e9nyt visszaadni. Ehhez az <code>operator+</code> f\u00fcggv\u00e9nyt kell t\u00falterhelni \u00fagy, hogy az egy komplex sz\u00e1mot adjon vissza \u00e9s k\u00e9t komplex sz\u00e1mot kapjon param\u00e9terk\u00e9nt, pl. <code>Komplex operator+(const Komplex&amp;, const Komplex&amp;)</code> :</p> <p> Futtasd!  <pre><code>Komplex operator+(const Komplex&amp; k1, const Komplex&amp; k2){\n    Komplex result;\n    result.re = k1.re + k2.re;\n    result.im = k1.im + k2.im;\n    return result;\n}\n\nint main(){\n    Komplex k1, k2;\n    k1.re = 4;\n    k1.im = 2;\n    k2.re = 1;\n    k2.im = 0;\n\n    Komplex eredmeny = k1 + k2;\n    std::cout &lt;&lt; eredmeny.re &lt;&lt; \" + \" &lt;&lt; eredmeny.im &lt;&lt; \"i\";\n}\n</code></pre></p> <p>A h\u00e1tt\u00e9rben az oper\u00e1tor h\u00edv\u00e1s \u00edgy n\u00e9z ki:</p> <pre><code>Komplex eredmeny = operator+(k1, k2);\n</code></pre>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/","title":"Oszt\u00e1lyok, objektumok","text":"<p>Warning</p> <p>Ez egy viszonylag hossz\u00fa fejezet, azonban a nyelv meg\u00e9rt\u00e9s\u00e9hez esszenci\u00e1lis!</p>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#osztaly-objektum","title":"Oszt\u00e1ly, objektum","text":"<p>A C nyelvben m\u00e1r megismerhett\u00fck a <code>struct</code> kulcssz\u00f3t, ami azonos dologhoz tartoz\u00f3 adatokat t\u00e1rolt. Val\u00f3sz\u00edn\u0171leg sok olyan f\u00fcggv\u00e9nyt \u00edrtunk ekkor, hogy</p> <p><pre><code>struct foo {};\n\nvoid foo_szamol(struct foo* this) {}\n</code></pre> \u00e9s t\u00e1rsai. J\u00f3 lenne, ha a <code>foo_szamol</code> f\u00fcggv\u00e9nyt valahogyan a <code>foo</code> strukt\u00far\u00e1hoz k\u00f6thetn\u00e9nk. (A param\u00e9ter neve nem v\u00e9letlen\u00fcl <code>this</code> !)</p> <p>Oszt\u00e1ly: \u00e1llapot (state), valamint ezen az \u00e1llapoton elv\u00e9gzett m\u0171veletek.</p> <ul> <li>A bels\u0151 m\u0171k\u00f6d\u00e9s az oszt\u00e1lyt haszn\u00e1l\u00f3 programoz\u00f3 el\u0151l rejtve marad: absztrakci\u00f3.</li> <li>C\u00e9l: \u00fajrafelhaszn\u00e1lhat\u00f3s\u00e1g, \u00e1ltal\u00e1nos\u00edthat\u00f3s\u00e1g</li> </ul> <p>Egy oszt\u00e1lyt a <code>class</code> vagy a <code>struct</code> kulcssz\u00f3val (k\u00fcl\u00f6nbs\u00e9g k\u00e9s\u0151bb) tudunk defini\u00e1lni, <code>typedef</code> haszn\u00e1lat\u00e1ra egy\u00e1ltal\u00e1n nincs sz\u00fcks\u00e9g.</p> <p>Egy oszt\u00e1lyb\u00f3l \"p\u00e9ld\u00e1nyokat\" hozhatunk l\u00e9tre, ez gyakorlatilag azt jelenti, hogy az adott oszt\u00e1ly t\u00edpus\u00fa v\u00e1ltoz\u00f3t hozunk l\u00e9tre a C strukt\u00far\u00e1khoz hasonl\u00f3an.</p> <pre><code>class Foo {};\n\nint main(){\n    Foo f;\n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#publikus-es-privat-eleres","title":"Publikus \u00e9s priv\u00e1t el\u00e9r\u00e9s","text":"<p>Egy oszt\u00e1ly tartalmazhat \"member\"-eket (tagokat), amelyeknek k\u00fcl\u00f6nb\u00f6z\u0151 l\u00e1that\u00f3s\u00e1gai lehetnek.  Ezt a <code>public</code>, <code>private</code> \u00e9s <code>protected</code> (k\u00e9s\u0151bb) szavakkal \u00e1ll\u00edthatjuk be. Ezeket a kulcsszavakat access specifier-nek h\u00edvjuk. A priv\u00e1t tagokat csak az oszt\u00e1lyon bel\u00fclr\u0151l, a public-okat k\u00edv\u00fclr\u0151l is el\u00e9rhetj\u00fck. Egy oszt\u00e1lyban alapb\u00f3l minden private, am\u00edg ezt meg nem v\u00e1ltoztatjuk.</p> <p> Futtasd!  <pre><code>class Foo {\npublic: //ez ut\u00e1n a k\u00f6vetkez\u0151 access-specifier -ig minden public.\n    int x;\nprivate: //ez ut\u00e1n a k\u00f6vetkez\u0151 access-specifier -ig minden private.\n    double y;\n};\n\nint main(){\n    Foo f;\n    f.x = 5;\n    f.y = 2.3; //hiba, y private\n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#tagfuggvenyek-member-functions","title":"Tagf\u00fcggv\u00e9nyek (member functions)","text":"<p>Az oszt\u00e1lyok f\u00fcggv\u00e9nyeket tartalmazhatnak, amelyek az oszt\u00e1ly \u00e1ltal t\u00e1rolt \u00e1llapoton (state) oper\u00e1lnak.</p> <p>A <code>this</code> pointer egy oszt\u00e1lyon bel\u00fcl arr az adott p\u00e9ld\u00e1nyra vonatkozik amire a tagf\u00fcggv\u00e9ny meg lett h\u00edvva, viszont ki\u00edrni csak akkor kell, ha egy tagf\u00fcggv\u00e9ny param\u00e9tere miatt egy n\u00e9v nem egy\u00e9rtelm\u0171. A tagf\u00fcggv\u00e9nyek gyakorlatilag speci\u00e1lis f\u00fcggv\u00e9nyek, amelyek els\u0151 param\u00e9tere a rejtett <code>this</code> pointer. </p> <p>Egy tagf\u00fcggv\u00e9ny lehet <code>const</code>, ami azt jelenti, hogy nem v\u00e1ltoztatja meg az objektum \u00e1llapot\u00e1t, \u00edgy <code>const</code> objektumon is m\u0171k\u00f6dik. FONTOS egy tagf\u00fcggv\u00e9ny t\u00falt\u00f6lthet\u0151 az alapj\u00e1n, hogy <code>const</code> -e, vagy nem, a <code>const</code> qualifier r\u00e9sze a f\u00fcggv\u00e9ny fejl\u00e9c\u00e9nek! (signature)</p> <p>N\u00e9zz\u00fcnk meg egy p\u00e9ld\u00e1t: a <code>Square</code> oszt\u00e1ly t\u00e1rol egy priv\u00e1t val\u00f3s \u00e9rt\u00e9ket, amely az oldalhossz\u00e1t reprezent\u00e1lja. Vannak ezen fel\u00fcl az oldalhosszt lek\u00e9r\u0151 \u00e9s be\u00e1ll\u00edt\u00f3 (getter/setter) tagf\u00fcggv\u00e9nyek, valamint egy tagf\u00fcggv\u00e9ny amely megadja, hogy a n\u00e9gyzetnek mennyi a ter\u00fclete. Vegy\u00fck \u00e9szre, hogy a ter\u00fclet sz\u00e1m\u00edt\u00e1s\u00e1hoz nem kell param\u00e9ter, hiszen a <code>this</code> param\u00e9teren kereszt\u00fcl tudjuk annak a n\u00e9gyzetnek az oldalhossz\u00e1t, amelyre a tagf\u00fcggv\u00e9nyt megh\u00edvtuk.</p> <p> Futtasd!  <pre><code>class Square{\nprivate:\n    double side_length; //priv\u00e1t, \u00edrunk r\u00e1 publikus set \u00e9s get f\u00fcggv\u00e9nyt.\n\npublic:\n    //\"Setter\" f\u00fcggv\u00e9ny, nagyon hasznos ha nem trivi\u00e1lis egy \u00e9rt\u00e9k be\u00e1ll\u00edt\u00e1sa(pl. itt side_length &gt; 0 check miatt)\n    void set_side_length(double side_length){\n        if(side_length &lt;= 0) { \n            throw std::runtime_error(\"side length &lt;= 0 is not allowed\");\n        }\n\n    //this-&gt;side_length: az adott p\u00e9ld\u00e1ny oldalhossza,\n    //side_length: a tagf\u00fcggv\u00e9ny param\u00e9tere\n        this-&gt;side_length = side_length; \n    }\n\n    double get_side_length() const { //const, mivel nem v\u00e1ltoztatja a p\u00e9ld\u00e1nyt.\n        return side_length; //nem kell this-&gt; mivel nincs n\u00e9v konfliktus.\n    }\n\n    double calculate_area() const { //const, mivel csak sz\u00e1mol, ez sem v\u00e1ltoztat semmit\n        return side_length * side_length;\n    }\n};\n</code></pre> Tagf\u00fcggv\u00e9nyeket a <code>.</code> oper\u00e1torral \u00e9rhet\u00fcnk el: <pre><code>int main(){\n    Square square;\n    square.set_side_length(2.5);\n    std::cout &lt;&lt; square.calculate_area();\n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#konstruktor-destruktor-es-raii","title":"Konstruktor, destruktor \u00e9s RAII","text":"<p>Most j\u00f6n tal\u00e1n a C++ legfontosabb r\u00e9sze. A RAII (Resource Acquisition Is Initialization), de h\u00edvhatjuk \"Scope Based Resource Management-nek is (ink\u00e1bb jegyezz\u00fck meg ezt, ez sokkal \u00e9rthet\u0151bb), m\u00f3dszer szerint egy objektum \u00e9lettartama kezdet\u00e9n (construction) \u00e1tveszi \u00e9s lefoglalja a sz\u00e1m\u00e1ra sz\u00fcks\u00e9ges er\u0151forr\u00e1sokat (mem\u00f3ria, adatb\u00e1zishoz csatlakoz\u00e1s, stb.) \u00e9s \u00e9lettartama v\u00e9g\u00e9n (destruction) felszabad\u00edtja, bez\u00e1rja ezeket az er\u0151forr\u00e1sokat.</p> <p>Konstruktor:  Az objektum l\u00e9trej\u00f6ttekor h\u00edv\u00f3dik. Feladata, hogy alap\u00e1llapotba hozza az objektumot. Ha egy oszt\u00e1lyban minden tagv\u00e1ltoz\u00f3nak van default konstruktora, \u00e9s mi nem \u00edrtunk k\u00fcl\u00f6n konstruktort, akkor az oszt\u00e1lynak gener\u00e1l\u00f3dik default konstruktor. </p> <p>Destruktor:  Az objektum megsz\u00fcntet\u00e9sekor h\u00edv\u00f3dik. Alapvet\u0151 feladata, hogy megsz\u00fcntesse az objektum \u00e1ltal lefoglalt dinamikus er\u0151forr\u00e1sokat (pl. dinamikus mem\u00f3riafoglal\u00e1s, adatb\u00e1zis csatlakoz\u00e1s)</p> <p>A konstruktornak \u00e9s destruktornak nincs visszat\u00e9r\u00e9si \u00e9rt\u00e9ke. A konstruktor f\u00fcggv\u00e9ny neve mindig megegyezik az oszt\u00e1ly nev\u00e9vel, a destruktor neve pedig <code>~osztaly_neve</code>. Objektum l\u00e9trehoz\u00e1sa alatt azt \u00e9rtj\u00fck, amikor egy lok\u00e1lis v\u00e1ltoz\u00f3t defini\u00e1lunk az adott oszt\u00e1lyt\u00edpussal (automatikus \u00e9lettartam\u00fa objektumot hozunk l\u00e9tre), vagy a <code>new</code> oper\u00e1torral dinamikus \u00e9lettartam\u00fa objektumot hozunk l\u00e9tre. Lok\u00e1lis v\u00e1ltoz\u00f3hoz k\u00f6t\u00f6tt objektum \u00e9lettartama a v\u00e1ltoz\u00f3 defini\u00e1l\u00e1s\u00e1t\u00f3l legfeljebb a scope v\u00e9g\u00e9ig, dinamikus \u00e9lettartam\u00fa objektum \u00e9lettartama a lefoglal\u00e1s\u00e1t\u00f3l(<code>new</code>) a felszabad\u00edt\u00e1s\u00e1ig(<code>delete</code>) tart.</p> <pre><code>class Foo{\n    Foo() {\n        std::cout &lt;&lt; \"Foo ctor\\n\";\n    }\n\n    ~Foo() {\n        std::cout &lt;&lt; \"Foo dtor\\n\";\n    }\n};\n\nint main(){\n    Foo f; //foo ctor lefut\n    /*\n    ...\n    */\n\n    return 0; //foo dtor lefut\n}\n</code></pre> <p>Azt a konstruktort, amely param\u00e9ter n\u00e9lk\u00fcl h\u00edvhat\u00f3, defualt konstruktornak nevezz\u00fck. </p> <p>Egy oszt\u00e1lyb\u00f3l csak akkor hozhat\u00f3 l\u00e9tre (C \u00e9rtelemben vett) t\u00f6mb, ha annak van default konstruktora.</p> <p>A konstruktor arra val\u00f3, hogy egy p\u00e9ld\u00e1ny alap \u00e9rt\u00e9keit be\u00e1ll\u00edtsuk, viszont a konstruktorba \u00edrt k\u00f3d val\u00f3j\u00e1ban az objektum l\u00e9trej\u00f6tte ut\u00e1n fut, \u00edgy pl. konstans tagv\u00e1ltoz\u00f3kat nem tudunk be\u00e1ll\u00edtani itt, ez\u00e9rt a tagv\u00e1ltoz\u00f3k inicializ\u00e1l\u00e1s\u00e1t \u00e1ltal\u00e1ban a \"member initialization list\" -en tessz\u00fck meg. Ennek kicsit furcsa szintaxisa van: <code>classname() : member1(value1), member2(value2)</code> Vegy\u00fck \u00fajra p\u00e9ld\u00e1nak a <code>Square</code> oszt\u00e1lyt.</p> <p> Futtasd!  <pre><code>class Square{\nprivate:\n    double side_length; //priv\u00e1t, \u00edrunk r\u00e1 publikus set \u00e9s get f\u00fcggv\u00e9nyt.\n    std::string name; //std::string : egy dinamikusan n\u00f6v\u0151 karakter t\u00f6mb, modern nyelvekt\u0151l elv\u00e1rt string t\u00edpus\npublic:\n    // : side_length(side_length) -&gt; a side_length nev\u0171 tagv\u00e1ltoz\u00f3t inicializ\u00e1ljuk a side_length nev\u0171 param\u00e9terrel\n    // vessz\u0151vel v\u00e1lasztjuk el a tagokat\n    Square(double side_length, const std::string&amp; name) : side_length(side_length), name(name) {\n    } //\u00edgy m\u00e1r lehet const Square is haszn\u00e1lhat\u00f3 objektum\n\n    //\"Setter\" f\u00fcggv\u00e9ny, nagyon hasznos ha nem trivi\u00e1lis egy \u00e9rt\u00e9k be\u00e1ll\u00edt\u00e1sa(pl. itt side_length &gt; 0 check miatt)\n    void set_side_length(double side_length){\n        if(side_length &lt;= 0) { \n            throw std::runtime_error(\"side length &lt;= 0 is not allowed\");\n        }\n\n        this-&gt;side_length = side_length; //this-&gt;side_length: az adott p\u00e9ld\u00e1ny oldalhossza, side_length: a tagf\u00fcggv\u00e9ny param\u00e9tere\n    }\n\n    double get_side_length() const { //const, mivel nem v\u00e1ltoztatja a p\u00e9ld\u00e1nyt.\n        return side_length; //nem kell this-&gt; mivel nincs n\u00e9v konfliktus.\n    }\n};\n\nint main(){\n    Square square(5.3, \"foo\"); //konstruktor h\u00edv\u00e1s\n    Square square; //ez most nem m\u0171k\u00f6dik, mert Square-nek nincs default konstruktora. \n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#gyakori-felreertesek-static-tagfuggvenyek","title":"Gyakori f\u00e9lre\u00e9rt\u00e9sek, static tagf\u00fcggv\u00e9nyek","text":"<p>adatb\u00e1zisok referencia k\u00f6vetkezik Amikor egy oszt\u00e1lyt hozunk l\u00e9tre, azzal m\u00e9g nem j\u00f6n l\u00e9tre objektum. Az oszt\u00e1ly egy tervrajz, egy valami le\u00edr\u00e1sa. Ez az objektumorient\u00e1lt programoz\u00e1s alapelve. A val\u00f3 vil\u00e1g (vagy esetleg kital\u00e1lt vil\u00e1g) dolgair\u00f3l k\u00e9sz\u00fclt tervrajzokb\u00f3l hozunk l\u00e9tre p\u00e9ld\u00e1nyokat. Egy oszt\u00e1ly egy p\u00e9ld\u00e1ny\u00e1t nevezz\u00fck \u00e1ltal\u00e1ban objektumnak.</p> <p>Pl.</p> <pre><code>class foo{};\n\nint main(){\n    foo f; // f a foo oszt\u00e1ly egy p\u00e9ld\u00e1nya\n}\n</code></pre> <p>Amikor egy oszt\u00e1lyban egy tagv\u00e1ltoz\u00f3t \u00e9r\u00fcnk el, az az adott p\u00e9ld\u00e1ny tagv\u00e1ltoz\u00f3j\u00e1ra vonatkozik. Eml\u00e9kezz\u00fcnk vissza, a tagv\u00e1ltoz\u00f3k el\u00e9r\u00e9se (m\u00e9g ha implicit m\u00f3don is) a <code>this</code> pointeren kereszt\u00fcl t\u00f6rt\u00e9nik, azaz a p\u00e9ld\u00e1nyunkra mutat\u00f3 pointeren kereszt\u00fcl.</p> <p>Vannak azonban esetek amikor valamilyen \u00e1llapotot nem egy p\u00e9ld\u00e1nyhoz, hanem az oszt\u00e1lyhoz szeretn\u00e9nk k\u00f6tni. Nos erre val\u00f3 a <code>static</code> kulcssz\u00f3. Egy statikus tagv\u00e1ltoz\u00f3 nem a p\u00e9ld\u00e1nyokhoz, hanem az oszt\u00e1lyhoz tartozik, a statikus tagf\u00fcggv\u00e9ny ugyan\u00edgy az oszt\u00e1lyhoz tartozik. Term\u00e9szetesen ez azt is jelenti, hogy statikus tagv\u00e1ltoz\u00f3t/tagf\u00fcggv\u00e9nyt nem \u00e9rhet\u00fcnk el p\u00e9ld\u00e1nyon kereszt\u00fcl, valamint <code>non static</code> tagv\u00e1ltoz\u00f3kat \u00e9s tagf\u00fcggv\u00e9nyeket nem \u00e9rhet\u00fcnk el statikus tagf\u00fcggv\u00e9nyekb\u0151l.</p> <p>Statikus tagv\u00e1ltoz\u00f3kat a <code>::</code> oper\u00e1torral \u00e9rhet\u00fcnk el:  <code>foo::bar();</code></p> <pre><code>class foo{\n    public:\n        static void s_bar() {}\n        void m_bar() {}\n        int m_x;\n};\n\nint main(){\n    foo f;\n    f.m_bar(); //ok\n    f.m_x = 4; //ok\n    f.s_bar; //nem ok\n    foo::s_bar(); //ok\n    foo::m_x = 4; // nem ok\n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#egyetlen-felelosseg-elve","title":"Egyetlen felel\u0151ss\u00e9g elve","text":"<p>\"A module should be responsible to one, and only one, actor.\"  Nos ez egy kicsit furcsa lehet, sz\u00f3val vegy\u00fcnk egy \u00e9rthet\u0151bb megfogalmaz\u00e1st: Egy oszt\u00e1lynak egyetlen felel\u0151ss\u00e9get kell lefednie, viszont azt teljes m\u00e9rt\u00e9kben. </p> <p>Pl. A <code>string</code> oszt\u00e1lyunk kezeli a dinamikus karaktert\u00f6mb\u00f6t, viszont azzal nem foglalkozik, hogy a karaktereit egyes\u00e9vel hogy \u00edrjuk ki.</p>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#ownership","title":"Ownership","text":"<p>Van egy nagyon fontos t\u00e9ma, amit tiszt\u00e1zni kell. Minden er\u0151forr\u00e1s\u00e9rt felel valaki (\"owns\"). Az, hogy valami felel valami\u00e9rt annyit jelent (legal\u00e1bbis C++ programoz\u00e1s kontextus\u00e1ban), hogy kinek a dolga felszabad\u00edtani egy objektumhoz tartoz\u00f3 er\u0151forr\u00e1sokat (pl. mem\u00f3ria)</p> <p>Egy lok\u00e1lis, \"\u00e9rt\u00e9k\" v\u00e1ltoz\u00f3 gondoskodik saj\u00e1t mag\u00e1r\u00f3l, amikor scope-on k\u00edv\u00fcl ker\u00fcl, tisztess\u00e9gesen feltakar\u00edt maga ut\u00e1n. pl.</p> <pre><code>struct Foo{\n    int x;\n};\n\nint main(){\n    Foo f; // f itt eltakar\u00edtja az \u00e1ltala t\u00e1rolt x-et is\n}\n</code></pre> <p>N\u00e9zz\u00fck mi t\u00f6rt\u00e9nik akkor, ha dinamikusan foglaljuk Foo -n bel\u00fcl x-et.</p> <pre><code>struct Foo{\n    int* x;\n};\n\nint main(){\n    Foo f;\n    f.x = new int;\n    //ki fogja felszabad\u00edtani a mem\u00f3ri\u00e1t??\n}\n</code></pre> <p>A k\u00e9rd\u00e9s a k\u00f6vetkez\u0151: ki felel az x \u00e1ltal mutatott mem\u00f3ri\u00e1\u00e9rt? A v\u00e1lasz nem t\u00fal egy\u00e9rtelm\u0171, a programoz\u00f3 d\u00f6nt\u00e9se. Megoldhat\u00f3 p\u00e9ld\u00e1ul, hogy <code>Foo</code> feleljen \u00e9rte, ekkor <code>Foo</code> destruktora felszabad\u00edtja a foglalt mem\u00f3ri\u00e1t. N\u00e9zz\u00fcnk egy szebb p\u00e9ld\u00e1t</p> <pre><code>struct Tarolo{\n    Tarolo(int ertek) : x(new int) {\n        *x = ertek;\n    }\n\n    ~Tarolo(){\n        delete x;\n    }\n\n    private:\n    int x;\n};\n</code></pre> <p>A fenti a modellben a t\u00e1rol\u00f3 foglalja le \u00e9s kezeli a mem\u00f3ri\u00e1t. Ezt alkalmazzuk pl. sima t\u00e1rol\u00f3kn\u00e1l, ahol a dinamikusan foglalt t\u00f6mb\u00f6t az oszt\u00e1ly kezeli.</p> <p>Van azonban egy m\u00e1sik lehet\u0151s\u00e9g is:</p> <pre><code>struct Tarolo{\n    Tarolo(int* x) : x(x) {}\n\n    ~Tarolo(){\n        delete x;\n    }\n\n    private:\n    int x;\n};\n</code></pre> <p>Most a t\u00e1rol\u00f3 a h\u00edv\u00f3 f\u00e9lt\u0151l m\u00e1r egy pointert kap, viszont \u00e1tveszi a felel\u0151ss\u00e9get a mem\u00f3ria kezel\u00e9se felet. Ezt a technik\u00e1t alkalmazzuk pl. heterog\u00e9n kollekci\u00f3kn\u00e1l</p>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#komolyabb-osztaly-pelda","title":"Komolyabb oszt\u00e1ly p\u00e9lda","text":"<p>Most pedig n\u00e9zz\u00fcnk egy komolyabb p\u00e9ld\u00e1t.  A terv\u00fcnk egy dinamikusan n\u00f6v\u0151 t\u00f6mb oszt\u00e1lysablon l\u00e9trehoz\u00e1sa eg\u00e9sz sz\u00e1mokat fog t\u00e1rolni.</p> <p> Futtasd!  <pre><code>#include &lt;cstddef&gt; // std::size_t\n#include &lt;stdexcept&gt; // std::out_of_range\n#include &lt;iostream&gt; // std::cout\n\n\nclass DinTomb{\n    int* tomb; //pointer a dinamikus t\u00f6mbre\n    std::size_t meret; //a dinamikus t\u00f6mb m\u00e9rete\n\npublic:\n    /**\n     * @brief Default konstruktor, mindent 0-ra inicializ\u00e1l\n     */\n    DinTomb() : tomb(nullptr), meret(0) {}\n\n    /**\n     * @brief hozz\u00e1ad egy \u00faj elemet a t\u00f6mb v\u00e9g\u00e9hez. \n     Nagyon hasonl\u00edt a C-ben megismert algoritmushoz, csak malloc-free helyett new-delete[] van\n     * @param elem az elem amit hozz\u00e1adunk\n     */\n    void push_back(int elem) {\n        int* uj_tomb = new int[meret + 1];\n        for(std::size_t i = 0; i &lt; meret; ++i){\n            uj_tomb[i] = tomb[i];\n        }\n        uj_tomb[meret] = elem;\n        delete[] tomb; // delete[], mert t\u00f6mb\u00f6t szabad\u00edtunk fel.\n        tomb = uj_tomb;\n        ++meret;\n    }\n\n    std::size_t size() const { return meret; }\n\n    /**\n     * @brief indexel\u0151 f\u00fcggv\u00e9ny\n     * @param idx\n     * @return referencia az adott indexen l\u00e9v\u0151 elemre\n     * @throw std::out_of_range, ha t\u00falindexel\u00e9s t\u00f6rt\u00e9nik\n     */\n    int&amp; at(std::size_t idx) {\n        if(idx &gt;= meret) {\n            throw std::out_of_range(\"Tomb tulindexelve!\");\n        }\n        return tomb[idx];\n    }\n\n    //ua. mint az el\u0151bb, csak konstans verzi\u00f3\n    const int&amp; at(std::size_t idx) const { \n        if(idx &gt;= meret) {\n            throw std::out_of_range(\"Tomb tulindexelve!\");\n        }\n        return tomb[idx];\n    }\n\n    ~DinTomb() {\n        delete[] tomb; //destruktor felszabad\u00edtja a lefoglalt mem\u00f3ri\u00e1t\n    }\n};\n\nint main(){\n    DinTomb tomb; \n\n    tomb.push_back(4);\n    tomb.push_back(3);\n    tomb.at(0) = 5; //f\u00fcggv\u00e9ny az egyenl\u0151s\u00e9g bal oldal\u00e1n, mivel referenci\u00e1t ad vissza!\n    std::cout &lt;&lt; tomb.at(1);\n    return 0; \n    /*\n    nem kell semmi manu\u00e1lis mem\u00f3riakezel\u00e9s, \n    mert a destruktor automatikusan felszabad\u00edtja amit kell, mert egyszer meg\u00edrtuk\n    */\n}\n</code></pre></p> <p>Nos igen, ez a RAII (avagy Scope Based Resource Management) l\u00e9nyege. Nem kell manu\u00e1lisan sehol <code>delete</code> \u00e9s <code>new</code> -t \u00edrnunk az oszt\u00e1lyt haszn\u00e1l\u00f3 k\u00f3dban, ha sz\u00e9pen becsomagoltuk a mem\u00f3riakezel\u00e9st egy oszt\u00e1lyba. Az er\u0151forr\u00e1skezel\u00e9st elabsztrakt\u00e1ltuk a fels\u0151bb szint\u0171 k\u00f3d el\u0151l, \u00edgy ezt a t\u00f6mb oszt\u00e1lyt haszn\u00e1lva m\u00e1r nem kell a mem\u00f3riakezel\u00e9ssel foglalkoznunk.</p> <p>J\u00f3 RAII p\u00e9ld\u00e1k a m\u00e1r megismert filestream oszt\u00e1lyok. A konstruktorukban megnyitj\u00e1k a filet (elk\u00e9rik a file handle-t az OS-t\u0151l), majd a destruktorukban automatikusan bez\u00e1rj\u00e1k a file-t (elengedik a file handlet).</p>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#objektumok-masolasa","title":"Objektumok m\u00e1sol\u00e1sa","text":"<p>Tegy\u00fck fel, hogy a t\u00f6mb\u00fcnkb\u0151l m\u00e1solatot szeretn\u00e9nk csin\u00e1lni. Ez val\u00f3j\u00e1ban nem m\u00e1s, mint egy t\u00f6mbb\u0151l egy \u00faj t\u00f6mb\u00f6t csin\u00e1lunk. Azt a konstruktort, amely egy <code>T</code> t\u00edpus\u00fa objektumb\u00f3l <code>T</code> t\u00edpus\u00fa objektumot k\u00e9sz\u00edt m\u00e1sol\u00f3 konstruktor (copy constructor)-nak nevezz\u00fck.</p> <p>A copy constructor val\u00f3j\u00e1ban azt mondja meg, hogyan is k\u00e9ne lem\u00e1solni egy objektumot. Ez sok esetben trivi\u00e1lis, pl. <pre><code>class foo{\n    public:\n        int x;\n        float y;\n        double t;\n};\n</code></pre> Ha egy oszt\u00e1lynak minden tagv\u00e1ltoz\u00f3ja lem\u00e1solhat\u00f3 (van copy constructora, vagy pl. primit\u00edv t\u00edpus), akkor lesz automatikusan gener\u00e1lt copy constructora is. </p> <p>A copy constructor param\u00e9terek\u00e9nt <code>const T&amp;</code> -et vesz \u00e1t. Persze, hiszen a m\u00e1soland\u00f3 objektumot nem v\u00e1ltoztatjuk \u00e9s a nem referenciak\u00e9nt \u00e1tv\u00e9telhez (lem\u00e1sol\u00e1s\u00e1hoz) copy constructorra lenne sz\u00fcks\u00e9g. Ha p\u00e9ld\u00e1ul az oszt\u00e1lyunk egy dinamikusan n\u00f6v\u0151 t\u00f6mb\u00f6t kezel, nem m\u00e1solhatjuk le egyszer\u0171en a t\u00f6mbre mutat\u00f3 pointert, hanem a t\u00f6mb\u00f6t elemenk\u00e9nt le kell m\u00e1solni (deep copy). Ennek oka az, hogy a pointer lem\u00e1sol\u00e1s\u00e1val (shallow copy, ez a default) az egyik t\u00f6mb destruktora felszabad\u00edtja mindk\u00e9t t\u00f6mb\u00f6t. https://en.wikipedia.org/wiki/Object_copying</p> <p>Fontos!</p> <p>N\u00e9h\u00e1ny olvas\u00f3 esetleg ismerheti a <code>memcpy</code> f\u00fcggv\u00e9nyt. C++ objektumokat <code>memcpy</code>-vel (\u00e9s <code>std::memcpy</code>-vel) m\u00e1solni \u00f3ri\u00e1si hiba, mivel ilyenkor nem h\u00edv\u00f3dnak meg az objektumok m\u00e1sol\u00f3 konstruktorai!</p> <pre><code>class DinTomb{\n    int* tomb; //pointer a dinamikus t\u00f6mbre\n    std::size_t meret; //a dinamikus t\u00f6mb m\u00e9rete\n\npublic:\n    /**\n     * @brief Default konstruktor, mindent 0-ra inicializ\u00e1l\n     */\n    DinTomb() : tomb(nullptr), meret(0) {}\n\n    /**\n     * @brief M\u00e1sol\u00f3 konstruktor\n     * @param other a m\u00e1sik t\u00f6mb amit m\u00e1solunk\n     */\n    DinTomb(const DinTomb&amp; other) : tomb(other.tomb != nullptr ? new int[other.meret] : nullptr), meret(other.meret) {\n        for(std::size_t i = 0; i &lt; other.meret; ++i){\n            tomb[i] = other.tomb[i]; //elemenk\u00e9nt lem\u00e1soljuk a r\u00e9gi t\u00f6mb\u00f6t az \u00fajba\n        }\n    }\n\n    ~DinTomb() {\n        delete[] tomb; //destruktor felszabad\u00edtja a lefoglalt mem\u00f3ri\u00e1t\n    }\n};\n</code></pre>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#class-vs-struct","title":"class vs struct","text":"<p>A <code>struct</code> keyword C++ -ban gyakorlatilag egy alternat\u00edva oszt\u00e1lyok defini\u00e1l\u00e1s\u00e1ra. A <code>class</code> -t\u00f3l annyiban k\u00fcl\u00f6nb\u00f6zik, hogy <code>private</code> helyett alap\u00e9rtelmezetten minden <code>public</code> benne (C kompatibilit\u00e1s miatt). Az, hogy valaki <code>class</code>-t vagy <code>struct</code>-ot haszn\u00e1l, preferencia.</p>"},{"location":"T%C3%B6rzsanyag/6-osztalyok/#osztalyok-tagfuggvenyei-tobbmodulos-programokban","title":"Oszt\u00e1lyok tagf\u00fcggv\u00e9nyei t\u00f6bbmodulos programokban","text":"<p>Ha egy oszt\u00e1lynak saj\u00e1t header \u00e9s cpp file-t dezign\u00e1lunk, akkor azt a k\u00f6vetkez\u0151 szintaxissal tehetj\u00fck meg:</p> <p><code>foo.hpp</code> (a .hpp kiterjeszt\u00e9s gyakori c++ header fileokhoz, de term\u00e9szetesen a .h ugyan\u00edgy gyakori) <pre><code>class foo{\n    int x;\n    static int y;\n    public:\n    foo(int x);\n    void set_x(int x);\n    int get_x() const;\n\n    static void something();\n\n\n    template &lt;typename T&gt; // template defin\u00edci\u00f3t headerbe!\n    void print_with_x(T thing) const {\n        std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; thing;\n    }\n};\n</code></pre></p> <p>A .cpp fileban a <code>returntype classname::functionname(params...)</code> szintaktik\u00e1t haszn\u00e1ljuk.</p> <p>Note</p> <p>Ezt az\u00e9rt \u00edgy kell, mert a tagf\u00fcggv\u00e9nyek val\u00f3di neve <code>classname::functionname</code>, azaz igaz\u00e1b\u00f3l ez semmi extra, ugyanazt kell csin\u00e1lni, mint C-ben.</p> <p>A statikus tagv\u00e1ltoz\u00f3kat is itt kell defini\u00e1lni, itt a <code>type classname::variablename = somevalue;</code> szintaktik\u00e1t haszn\u00e1ljuk. Oszt\u00e1lydefin\u00edci\u00f3n k\u00edv\u00fcl a <code>static</code> m\u00e1st jelent, \u00edgy ki\u00edrni nagy hiba.</p> <p><code>foo.cpp</code> <pre><code>int foo::y = 1; //statikus tagv\u00e1ltoz\u00f3 defin\u00edci\u00f3ja\n\nfoo::foo(int x) : x(x) {} //konstruktor defin\u00edci\u00f3ja\n\nvoid foo::set_x(int x){\n    this-&gt;x = x;\n}\n\n//fontos! a const r\u00e9sze a f\u00fcggv\u00e9ny fej\u00e9c\u00e9nek(signature), itt is ki kell \u00edrni.\nint foo::get_x() const { \n    return x;\n}\n\nvoid foo::something(){\n    y*=2;\n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/7-operator-overloading/","title":"Oper\u00e1torok \u00fajra, b\u0151vebben","text":""},{"location":"T%C3%B6rzsanyag/7-operator-overloading/#operatorok-es-osztalyok","title":"Oper\u00e1torok \u00e9s oszt\u00e1lyok","text":"<p>Ha egy oper\u00e1tor az adott oszt\u00e1ly t\u00edpust veszi \u00e1t baloldali param\u00e9terk\u00e9nt (vagy un\u00e1ris, egyparam\u00e9ter\u0171 oper\u00e1tor), akkor az oper\u00e1tort az oszt\u00e1lyon bel\u00fcl tagf\u00fcggv\u00e9nyk\u00e9nt kezelhetj\u00fck. Ekkor az els\u0151 (\"bal oldali\") param\u00e9tere automatikusan a <code>this</code> pointer lesz.</p>"},{"location":"T%C3%B6rzsanyag/7-operator-overloading/#copy-assignmentertekado-operator","title":"Copy assignment(\u00e9rt\u00e9kad\u00f3 oper\u00e1tor)","text":"<p>Vannak olyan esetek, amikor m\u00e1r egy k\u00e9sz objektumnak akarunk \u00faj \u00e9rt\u00e9ket adni.  Pl.</p> <pre><code>DinTomb tomb1;\ntomb1.push_back(5);\n\nDinTomb tomb2;\ntomb2.push_back(1);\n\ntomb1 = tomb2;\n</code></pre> <p>Ilyen esetekben egy \u00e9rt\u00e9kad\u00f3 oper\u00e1tor(copy assignment operator) h\u00edv\u00e1sr\u00f3l besz\u00e9l\u00fcnk.</p> <p>A m\u00e1sol\u00f3 konstruktor testv\u00e9re a copy assignment(\u00e9rt\u00e9kad\u00f3) operator. A copy constructorhoz hasonl\u00f3an <code>const T&amp;</code> -k\u00e9nt veszi \u00e1t a m\u00e1soland\u00f3 objektumot \u00e9s a default is gener\u00e1l\u00f3dik bel\u0151le. Fontos, hogy a copy assignment oper\u00e1tor nem \u00faj objektumot hoz l\u00e9tre \u00edgy az el\u0151z\u0151leg haszn\u00e1lt er\u0151forr\u00e1sokat fel kell szabad\u00edtani.</p> <pre><code>class DinTomb{\n    int* tomb;\n    std::size_t meret;\n\npublic:\n    /**\n     * @brief Default konstruktor, mindent 0-ra inicializ\u00e1l\n     */\n    DinTomb() : tomb(nullptr), meret(0) {}\n\n\n    /**\n     * @brief M\u00e1sol\u00f3 konstruktor\n     * @param other a m\u00e1sik t\u00f6mb amit m\u00e1solunk\n     */\n    DinTomb(const DinTomb&amp; other) : tomb(other.tomb != nullptr ? new int[other.meret] : nullptr), meret(other.meret) {\n        for(std::size_t i = 0; i &lt; other.meret; ++i){\n            tomb[i] = other.tomb[i];\n        }\n    }\n\n    /**\n     * @brief \u00c9rt\u00e9kad\u00f3 oper\u00e1tor\n     * @param other a m\u00e1sik t\u00f6mb amit m\u00e1solunk\n     * @return referencia a t\u00f6mbre aminek \u00e9rt\u00e9ket adtunk\n     */\n    DinTomb&amp; operator=(const DinTomb&amp; other){\n        if(this == &amp;other) { //ha \u00f6nmag\u00e1t kapja param\u00e9ter\u00fcl akkor nincs semmi teend\u0151, ne v\u00e1gjuk magunk alatt a f\u00e1t\n            return *this; // *this -&gt; this: pointer, akkor *this referencia(az objektumra amin a h\u00edv\u00e1s t\u00f6rt\u00e9nt)\n        }\n        delete[] tomb;\n        tomb = new int[other.meret];\n        meret = other.meret;\n        for(std::size_t i = 0; i &lt; other.meret; ++i) {\n            tomb[i] = other.tomb[i];\n        }\n        return *this;\n    }\n\n    ~DinTomb() {\n        delete[] tomb;\n    }\n};\n\nint main(){\n\n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/7-operator-overloading/#egyeb-operatorok","title":"Egy\u00e9b oper\u00e1torok","text":"<p>Szeretn\u00e9nk, hogy a t\u00f6mb\u00fcnkh\u00f6z a += oper\u00e1torral is lehessen \u00faj elemet hozz\u00e1adni. Ehhez t\u00fal kell t\u00f6lten\u00fcnk += oper\u00e1tort. A += oper\u00e1torra \"f\u00fcggv\u00e9nyk\u00e9nt\" az <code>operator+=</code> kifejez\u00e9ssel hivatkozhatunk.</p> <p>N\u00e9zz\u00fcnk egy p\u00e9ld\u00e1t:</p> <pre><code>class DinTomb{\n    /* \n        ...\n    */\n\n    void operator+=(const T&amp; elem){\n        push_back(elem); //deleg\u00e1ljuk a beilleszt\u00e9st a push_back f\u00fcggv\u00e9nynek, nem duplik\u00e1lunk k\u00f3dot.\n    }\n};\n\nint main(){\n    DinTomb tomb;\n    tomb += 5.2; // \u00e9rtelmezz\u00fck: tomb.operator+=(5.2) -&gt; operator+=(&amp;tomb, 5.2)\n\n    return 0;\n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/7-operator-overloading/#friend","title":"Friend","text":"<p>Most szeretn\u00e9nk, ha a t\u00f6mb\u00fcnket ki is lehetne \u00edrni. Viszont ezzel van egy kis gond. Azt, hogy hova \u00edrjuk ki a t\u00f6mb\u00f6t(stdout, file, stb.) bal\u00e9rt\u00e9kk\u00e9nt veszi \u00e1t az <code>operator&lt;&lt;</code> (stream insertion operator), ez\u00e9rt ezt az oszt\u00e1lyon k\u00edv\u00fck kell t\u00falt\u00f6lteni.  A <code>friend</code> kulcssz\u00f3 haszn\u00e1lat\u00e1val az oszt\u00e1lyon bel\u00fcl deklar\u00e1ljuk a f\u00fcggv\u00e9nyt, ezzel \"megengedjuk\" neki, hogy a priv\u00e1t tagokat is l\u00e1ssa. Eztun\u00e1n az oszt\u00e1lyon k\u00edv\u00fcl defini\u00e1ljuk.</p> <p><pre><code>#include &lt;iostream&gt;\n\nclass DinTomb{\n    /* \n        ...\n    */\n\n    template&lt;typename K&gt;\n    friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const DinTomb&lt;K&gt;&amp; dtomb);\n};\n\ntemplate&lt;typename K&gt;\nstd::ostream&amp; operator&lt;&lt;(std::ostream&amp; out, const DinTomb&lt;K&gt;&amp; dtomb){\n    for(std::size_t i = 0; i &lt; dtomb.meret; ++i){\n        out &lt;&lt; dtomb.tomb[i] &lt;&lt; ' ';\n    }\n\n    return out;\n}\n\nint main(){\n    DinTomb tomb;\n    tomb += 5.2; // \u00e9rtelmezz\u00fck: tomb.operator+=(5.2) -&gt; operator+=(&amp;tomb, 5.2)\n    tomb += 2.3;\n    tomb.push_back(8.7);\n\n    std::cout &lt;&lt; tomb; //\u00e9rtsd: operator&lt;&lt;(std::cout, tomb);\n    return 0;\n}\n</code></pre> Ha az <code>operator&lt;&lt;</code>-t streamre val\u00f3 ki\u00edr\u00e1sra haszn\u00e1ljuk, akkor mindig <code>std::ostream&amp;</code> -et ad vissza \u00e9s vesz \u00e1t bal operandusk\u00e9nt, valamint visszaadja a bal operandus\u00e1t, \u00edgy l\u00e1ncolhat\u00f3v\u00e1 teszi az oper\u00e1tort. (<code>std::cout &lt;&lt; a &lt;&lt; b &lt;&lt; c;</code>)</p> <p>Term\u00e9szetesen ezt a p\u00e9ld\u00e1t <code>friend</code> n\u00e9lk\u00fcl is meg lehet oldani, azonban ez nem mindig van \u00edgy.</p>"},{"location":"T%C3%B6rzsanyag/7-operator-overloading/#rule-of-03","title":"Rule of 0/3","text":"<p>https://en.cppreference.com/w/cpp/language/rule_of_three</p> <p>Rule of 3: Ha egy oszt\u00e1lynak sz\u00fcks\u00e9ge van nem compiler-default destruktorra, m\u00e1sol\u00f3 konstruktorra vagy copy assignment oper\u00e1torra akkor majdnem biztosan sz\u00fcks\u00e9ge van mindh\u00e1romra.</p> <p>advanced Rule of 0: Azok az oszt\u00e1lyok, amelyeknek nem compiler-default destructora, copy constructora, copy assignment oper\u00e1tora van, azok valamilyen explicit er\u0151forr\u00e1s-birtokl\u00e1st val\u00f3s\u00edtanak meg. (https://en.cppreference.com/w/cpp/language/rule_of_three). Ett\u0151l elt\u00e9r\u0151 oszt\u00e1lyoknak ne legyen nem compiler-default destruktora, copy constructora vagy copy assignment oper\u00e1tora.</p>"},{"location":"T%C3%B6rzsanyag/7-operator-overloading/#nehany-kotottseg","title":"N\u00e9h\u00e1ny k\u00f6t\u00f6tts\u00e9g","text":"<p>Oper\u00e1tor t\u00falt\u00f6lt\u00e9ssel nem v\u00e1ltoztathat\u00f3 meg: * precedencia * asszocivit\u00e1s</p> <p>Ezen fel\u00fcl egyes oper\u00e1toroknak csak k\u00f6t\u00f6tt sz\u00e1m\u00fa param\u00e9tere lehet. A logikai(<code>||</code> \u00e9s <code>&amp;&amp;</code>) oper\u00e1torok t\u00falt\u00f6lt\u00e9se eset\u00e9n azok elvesztik a short-circuit tulajdons\u00e1gukat.</p>"},{"location":"T%C3%B6rzsanyag/7-operator-overloading/#osszehasonlito-operatorok","title":"\u00d6sszehasonl\u00edt\u00f3 oper\u00e1torok","text":"<p>Term\u00e9szetesen mindenf\u00e9le m\u00e1s oper\u00e1torokat, pl \u00f6sszehasonl\u00edt\u00f3, ennek neg\u00e1ltja, nagyobb, kisebb, stb. is overloadolhatunk. </p> <p>Pl. a t\u00f6mbjeink \u00f6sszehasonl\u00edt\u00e1sa:</p> <pre><code>template &lt;typename T&gt;\nclass DinTomb{\n    T* tomb; //pointer a dinamikus t\u00f6mbre\n    std::size_t meret; //a dinamikus t\u00f6mb m\u00e9rete\n\npublic:\n    //...\n\n    bool operator==(const DinTomb&amp; other) {\n        if(meret != other.meret) {\n            return false;\n        }\n\n        for(std::size_t i = 0; i &lt; meret; ++i) {\n            if(tomb[i] != other.tomb[i]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    bool operator !=(const DinTomb&amp; other) {\n        return !(*this == other);\n    }\n};\n</code></pre> <p>Pl. indexel\u0151 oper\u00e1tor:</p> <pre><code>template &lt;typename T&gt;\nclass DinTomb{\n    T* tomb; //pointer a dinamikus t\u00f6mbre\n    std::size_t meret; //a dinamikus t\u00f6mb m\u00e9rete\n\npublic:\n    //...\n\n    T&amp; at(std::size_t idx);\n\n    const T&amp; at(std::size_t idx);\n\n    T&amp; operator[](std::size_t idx){\n        return at(idx); //deleg\u00e1ljuk a feladatot a m\u00e1r implement\u00e1lt at() tagf\u00fcggv\u00e9nynek\n    }\n\n    const T&amp; operator[](std::size_t idx) const{\n        return at(idx);\n    }\n};\n</code></pre>"},{"location":"T%C3%B6rzsanyag/8-inheritance/","title":"Objektumorient\u00e1lt idi\u00f3ma","text":"<p>Senkit sem szeretn\u00e9k a sablonsz\u00f6veggel untatni, ha sz\u00e9p \u00e9s kerek le\u00edr\u00e1st keres\u00fcnk arra itt a wikip\u00e9dia.</p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#a-lenyeg","title":"A l\u00e9nyeg","text":"<p>Az objektumorient\u00e1lt programoz\u00e1s alapja, hogy minden dolog ami a programunkban l\u00e9tezik egy objektum. </p> <p>Encapsulation (Egys\u00e9gbe z\u00e1r\u00e1s) Az objektumok valamilyen blueprintek(C++ban classok) p\u00e9ld\u00e1nyai. Az oszt\u00e1lyok valamilyen \u00e1llapotot \u00e9s az azokon elv\u00e9gezhet\u0151 m\u0171veleteket \u00edrj\u00e1k le (tagv\u00e1ltoz\u00f3 ~ \u00e1llapot, tagf\u00fcggv\u00e9ny ~ m\u0171velet).</p> <p>Inheritance (\u00f6r\u00f6kl\u00e9s) Van olyan eset, amikor egy adott dolog egyben egy m\u00e1sik dolog, csak kicsit kieg\u00e9sz\u00edtve, megv\u00e1ltoztatva. Pl. a Hallgat\u00f3 egy egyetemi polg\u00e1r, viszont k\u00e9pes vizsg\u00e1t felvenni \u00e9s van kreditindexe. Ekkor az egyetemi polg\u00e1r a \"base class\" a hallgat\u00f3 pedig a \"subclass\" nevet kapja.</p> <p>Note</p> <p>Az \u00f6r\u00f6kl\u00e9s a viselked\u00e9s kieg\u00e9sz\u00edt\u00e9s\u00e9re val\u00f3, nem az adat \u00fajrafelhaszn\u00e1l\u00e1s\u00e1ra!</p> <p>Polymorphism K\u00e9z a k\u00e9zben j\u00e1r az \u00f6r\u00f6kl\u00e9ssel. A f\u0151 l\u00e9nyege, hogy egy base class -ra mutat\u00f3 dolog kaphat subclass objektumot, \u00e9s ezen a mutat\u00f3n kereszt\u00fcl val\u00f3 viselked\u00e9s a subclass viselked\u00e9s\u00e9t mutatja.</p> <p>Note</p> <p>C++ -ban polimorfizmust nem csak \u00f6r\u00f6kl\u00e9ssel lehet megval\u00f3s\u00edtani.</p> <p>Abstraction A legt\u00f6bb esetben nem \u00e9rdekel minket, hogy egy adott f\u00fcggv\u00e9ny vagy t\u00edpus pontosan hogy m\u0171k\u00f6dik, csak az, hogy mit csin\u00e1l. Pl. az <code>std::string</code> <code>push_back()</code> tagf\u00fcggv\u00e9nye beilleszt egy karaktert a sztring v\u00e9g\u00e9re, de az hogy ezt hogy tesz az az \u00e1tlag programoz\u00f3 sz\u00e1m\u00e1ra(a t\u00edpus felhaszn\u00e1l\u00f3ja) nem \u00e9rdekes.  Ezt az elvet a jegyzet is alkalmazni fogja, nem lesznek defini\u00e1lva tagf\u00fcggv\u00e9nyek, ha azok implement\u00e1ci\u00f3ja jelent\u00e9ktelen.</p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#inheritance","title":"Inheritance","text":"<p>A lesz\u00e1rmaz\u00e1s szintaktik\u00e1ja viszonylag egyszer\u0171:</p> <pre><code>class polgar{\npublic:\n    std::string name;\n    std::string neptun;\n    std::string get_decorated_name() const {\n        return name + std::string(\" \") + neptun;\n    }\n};\n\nclass hallgato : public polgar {\npublic:\n    double calculate_kreditindex();\n    std::vector&lt;Targy&gt; targyak;\n};\n</code></pre> <p>Egy adott lesz\u00e1rmazott p\u00e9ld\u00e1ny mem\u00f3riak\u00e9p\u00e9t ekkor valahogy \u00edgy kell elk\u00e9pzelni: </p> <p>Egyszerre t\u00f6bb oszt\u00e1lyb\u00f3l is le lehet sz\u00e1rmazni, valamint lesz\u00e1rmazottb\u00f3l is lehet tov\u00e1bb sz\u00e1rmaztatni: <pre><code>class A {};\nclass B {};\nclass C : public A, public B {}\n\nclass D : public A {};\nclass E : public D {};\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#polimorfizmus","title":"Polimorfizmus","text":"<p>Ha <code>hallgato</code> a <code>polgar</code> lesz\u00e1rmazottja, akkor <code>polgar</code> -ra mutat\u00f3 pointerek m\u00e1r k\u00e9pesek <code>hallgato</code> -ra mutatni, valamit <code>polgar</code> referencia tud <code>hallgato</code> objektumot alias-olni. </p> <p>Fontos!</p> <p>Az inverz nem igaz. <pre><code>    hallgato* h = new polgar;\n</code></pre> A <code>h</code> egy olyan objektumra mutat amiben nincs meg a teljes <code>hallgato</code> r\u00e9sz, azaz ezen kereszt\u00fcl <code>hallgato</code> objektumot el\u00e9rni nagy hiba!</p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#object-slicing","title":"Object slicing","text":"<p>Fontos!</p> <p><code>polgar</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3ban <code>hallgato</code> objektumot t\u00e1rolni \u00e9s ford\u00edtva hiba! <code>polgar</code> t\u00edpus\u00fa v\u00e1ltoz\u00f3ba <code>halgato</code> t\u00edpus\u00fa objektumot rakva az objektum <code>hallgat\u00f3</code> r\u00e9sze lev\u00e1g\u00f3dik \u00e9s csak a <code>polgar</code> r\u00e9sze marad meg. Ezt object slicing-nak h\u00edvjuk.</p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#protected-tagok","title":"Protected tagok","text":"<p>A <code>private</code> tagok nem l\u00e1that\u00f3k a lesz\u00e1rmazottakb\u00f3l sem. A <code>protected</code> tagok a lesz\u00e1rmazottb\u00f3l l\u00e1tszanak, az oszt\u00e1lyon k\u00edv\u00fclr\u0151l viszont nem.</p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#inheritance-access-specifiers","title":"Inheritance access specifiers","text":"<p>Mint ahogyan tagokb\u00f3l, lesz\u00e1rmaz\u00e1sb\u00f3l is l\u00e9tezik publikus, protected \u00e9s private.</p> <pre><code>class Base {};\nclass A : public Base {};\nclass B : protected Base {};\nclass C : private Base {};\n</code></pre> <p>Ezt a k\u00f6vetkez\u0151k\u00e9pp kell \u00e9rteni:</p> <ul> <li>public: a subclass \u00e9s a k\u00fcls\u0151 k\u00f3d is tud a lesz\u00e1rmaz\u00e1sr\u00f3l, a lesz\u00e1rmazotton kereszt\u00fcl a subclass \u00e9s a k\u00fcls\u0151 k\u00f3d is el\u00e9ri a base class <code>public</code> tagjait, a <code>private</code> \u00e9s <code>protected</code> tagokat viszont nem</li> <li>protected: csak a subclass tud a lesz\u00e1rmaz\u00e1sr\u00f3l, a lesz\u00e1rmazotton kereszt\u00fcl csak a subclass \u00e9ri el a base class <code>public</code> tagjait, a k\u00fcls\u0151 k\u00f3d viszont egy\u00e1ltal\u00e1n nem \u00e9ri el a base class tagjait</li> <li>private: a subclass sem tud a lesz\u00e1rmaz\u00e1sr\u00f3l, a lesz\u00e1rmazotton kereszt\u00fcl nem \u00e9rhet\u0151ek el a base class tagjai.</li> </ul> <p>A <code>struct</code>-al defini\u00e1lt oszt\u00e1lyokn\u00e1l a lesz\u00e1rmaz\u00e1sn\u00e1l is <code>public</code> a default, m\u00edg a <code>class</code>-al defini\u00e1ltakn\u00e1l <code>private</code>.</p> <p>Gyakori k\u00e9rd\u00e9s: hogyan alakul a publikus, protected \u00e9s priv\u00e1t tagok l\u00e1that\u00f3s\u00e1ga publikus, protected \u00e9s priv\u00e1t \u00f6r\u00f6kl\u00e9s eset\u00e9n? ... megold\u00e1s\u00e1t az olvas\u00f3ra b\u00edzom</p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#virtualis-tagfuggvenyek","title":"Virtu\u00e1lis tagf\u00fcggv\u00e9nyek","text":"<p>Tegy\u00fck fel, hogy a hallgat\u00f3k dekor\u00e1lt nev\u00e9hez hozz\u00e1 szeretn\u00e9nk adni, hogy \"hallgat\u00f3\". Ehhez valahogyan \"fel\u00fcl kell \u00edrnunk\" a base class <code>get_decorated_name</code> f\u00fcggv\u00e9ny\u00e9t. Azokat a f\u00fcggv\u00e9nyeket amelyeket fel\u00fcl lehet \u00edrni virtu\u00e1lis tagf\u00fcggv\u00e9nyeknek h\u00edvunk \u00e9s a <code>virtual</code> keyworddel jelezz\u00fck \u0151ket.  A base class-ra mutat\u00f3 pointeren kereszt\u00fcl t\u00e1rolt subbclassnak a saj\u00e1t tagf\u00fcggv\u00e9ny verzi\u00f3ja h\u00edv\u00f3dik majd.</p> <p>Az <code>override</code> keyword opcion\u00e1lisan a fel\u00fcl\u00edr\u00f3 f\u00fcggv\u00e9ny fejl\u00e9ce ut\u00e1n ker\u00fcl, hasznos ki\u00edrni.</p> <p> Futtasd!  <pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct Targy {};\n\nclass polgar{\npublic:\n    std::string name;\n    std::string neptun;\n    virtual std::string get_decorated_name() const {\n        return name + std::string(\" \") + neptun;\n    }\n};\n\nclass hallgato : public polgar {\npublic:\n    double calculate_kreditindex();\n    std::vector&lt;Targy&gt; targyak;\n\n    virtual std::string get_decorated_name() const override {\n        return std::string(\"hallgato \") + name + std::string(\" \") + neptun;\n    }\n};\n\nint main(){\n    polgar* p = new hallgato;\n    p-&gt;name = \"Gipsz Jakab\";\n    p-&gt;neptun = \"ABC123\";\n    std::string name = p-&gt;get_decorated_name(); //hallgato tagf\u00fcggv\u00e9ny\u00e9t h\u00edvja\n    std::cout &lt;&lt; name; //hallgato Gipsz Jakab ABC123\n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#virtualis-fuggvenyhivasok-mukodese","title":"Virtu\u00e1lis f\u00fcggv\u00e9nyh\u00edv\u00e1sok m\u0171k\u00f6d\u00e9se","text":"<p>A nem-virtu\u00e1lis f\u00fcggv\u00e9nyh\u00edv\u00e1sok alapesetben ford\u00edt\u00e1sid\u0151ben k\u00f6t\u0151dnek a defin\u00edci\u00f3jukhoz. </p> <p>Amikor a ford\u00edt\u00f3 egy polimorfikus oszt\u00e1lyra (polimorfikus az oszt\u00e1ly, ha van virtu\u00e1lis tagf\u00fcggv\u00e9nye) mutat\u00f3 pointeren vagy referenci\u00e1n kereszt\u00fcl h\u00edvott virtu\u00e1lis tagf\u00fcggv\u00e9ny h\u00edv\u00e1st l\u00e1t, akkor a megh\u00edvott f\u00fcggv\u00e9ny ford\u00edt\u00e1si id\u0151 helyett fut\u00e1sid\u0151ben fog eld\u0151lni. Ez azt jelenti, hogy a programban valamilyen seg\u00e9dstrukt\u00fara seg\u00edts\u00e9g\u00e9vel a f\u00fcggv\u00e9nyh\u00edv\u00e1s pillanat\u00e1ban d\u0151l el, hogy melyik f\u00fcggv\u00e9nynek kell megh\u00edv\u00f3dnia. Ezt late-bindingnak h\u00edvjuk.</p> <p>Note</p> <p>Ez a folyamat csak pointeren \u00e9s referenci\u00e1n \u00e1t h\u00edvott virtu\u00e1lis tagf\u00fcggv\u00e9nyh\u00edv\u00e1sokra vonatkozik, hiszen \u00e9rt\u00e9k t\u00edpus\u00fa v\u00e1ltoz\u00f3 nem tartalmazhat lesz\u00e1rmazottat.</p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#kitekintes-vtable-a-dynamic-dispatch-egy-gyakori-implementacioja","title":"Kitekint\u00e9s: Vtable, a dynamic dispatch egy gyakori implement\u00e1ci\u00f3ja","text":"<p>A virtu\u00e1lis f\u00fcggv\u00e9nyh\u00edv\u00e1sok egy speci\u00e1lis, vtable -nek nevezett adatstrukt\u00far\u00e1n kereszt\u00fcl t\u00f6rt\u00e9nik. Amikor virtu\u00e1lis f\u00fcggv\u00e9nyt adunk egy oszt\u00e1lyhoz, akkor az oszt\u00e1ly kap egy rejtett t\u00f6mb\u00f6t, amely f\u00fcggv\u00e9nypointereket(\"f\u00fcggv\u00e9nyeket\") t\u00e1rol. Ez a t\u00f6mb t\u00e1rolja az adott oszt\u00e1ly implement\u00e1ci\u00f3j\u00e1t a virtu\u00e1lis f\u00fcggv\u00e9nyekre.</p> <p>Mi\u00e9rt sz\u00fcks\u00e9ges ez? Mivel base class pointer mutathat subclass objektumra, \u00edgy ford\u00edt\u00e1sid\u0151ben nem tudhatjuk, hogy melyik f\u00fcggv\u00e9nyt kell h\u00edvni, ez\u00e9rt fut\u00e1sid\u0151ben ezt a t\u00f6mb\u00f6t haszn\u00e1ljuk, hogy a helyes f\u00fcggv\u00e9nyt h\u00edvjuk.</p> <p>Mekkora overheaddel j\u00e1r ez? A v\u00e1lasz: depends. Gyakorlatilag semekkor\u00e1val, persze ez sok t\u00e9nyez\u0151t\u0151l f\u00fcgg. Gyenge hardveren(pl. mikrokontrollerek) probl\u00e9m\u00e1t jelenthet, azonban egy asztali sz\u00e1m\u00edt\u00f3g\u00e9pen val\u00f3sz\u00edn\u0171leg nem ez lesz a sz\u0171k keresztmetszet.</p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#pure-virtual-function-absztrakt-osztalyok","title":"Pure virtual function, absztrakt oszt\u00e1lyok","text":"<p>N\u00e9ha szeretn\u00e9nk azt, hogy a base class ne legyen val\u00f3ban p\u00e9ld\u00e1nyos\u00edthat\u00f3, hanem valamilyen f\u00fcggv\u00e9ny\u00e9t implement\u00e1lja minden subclass. Az ilyen f\u00fcggv\u00e9nyeket pure virtual functionnak, az oszt\u00e1ly t pedig absztrakt oszt\u00e1lynak nevezz\u00fck. Pure virtual function-t az <code>=0</code> postfix-el deklar\u00e1lhatunk.</p> <pre><code>struct base {\n    virtual void foo() = 0;\n};\n\nstruct derived : base {\n    virtual void foo() override {\n        std::cout &lt;&lt; \"pog\\n\";\n    }\n}\n\nint main(){\n    base b; //error, cannot instantiate abstract class\n    derived d; //ok\n    base* p = new derived; //ok, base* mutat derived objektumra\n    base* p2 = new base; //error, cannot instantiate abstract class\n\n}\n</code></pre> <p>Vegy\u00fck \u00e9szre: az <code>=0</code> szintaxis onnan j\u00f6n, hogy a vtable-ben a f\u00fcggv\u00e9ny hely\u00e9n egy 0 \u00e9rt\u00e9k, \"null pointer\" lesz.</p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#base-class-konstruktor-es-virtualis-destruktor","title":"Base class konstruktor \u00e9s virtu\u00e1lis destruktor","text":"<p>Amikor egy lesz\u00e1rmazott objektumot k\u00e9sz\u00edt\u00fcnk, akkor inicializ\u00e1lni kell annak base class \"r\u00e9sz\u00e9t\" is. Ehhez meg kell h\u00edvni a base class konstruktor\u00e1t (ha nincs neki default konstruktora). Ezt a m\u00e1r j\u00f3l ismert member initializer list-r\u0151l tehetj\u00fck meg.</p> <p> Futtasd!  <pre><code>#include &lt;string&gt;\n#include &lt;iostream&gt;\n#include &lt;vector&gt;\n\nstruct Targy {};\n\nclass polgar{\nprotected:\n    std::string name;\n    std::string neptun;\n\npublic:\n    virtual std::string get_decorated_name() const {\n        return name + std::string(\" \") + neptun;\n    }\n    polgar(const std::string&amp; name, const std::string&amp; neptun) : name(name), neptun(neptun) {}\n};\n\nclass hallgato : public polgar {\n    std::vector&lt;Targy&gt; targyak;\npublic:\n    hallgato(const std::string&amp; name, const std::string&amp; neptun) : polgar(name, neptun) //a polgar konstruktor\u00e1t h\u00edvjuk a name \u00e9s neptun param\u00e9terekkel\n    {}\n\n    double calculate_kreditindex();\n\n    virtual std::string get_decorated_name() const override {\n        return std::string(\"hallgato \") + name + std::string(\" \") + neptun;\n    }\n};\n\nint main(){\n    polgar* p = new hallgato(\"Gipsz Jakab\", \"ABC123\");\n\n    std::string name = p-&gt;get_decorated_name(); //hallgato tagf\u00fcggv\u00e9ny\u00e9t h\u00edvja\n    std::cout &lt;&lt; name; //hallgato Gipsz Jakab ABC123\n}\n</code></pre></p> <p><pre><code>polgar* p = new hallgato(\"Gipsz Jakab\", \"ABC123\");\n</code></pre> Azonban van egy kis baj... </p> <p>A probl\u00e9ma a destruktor k\u00e9rd\u00e9se. Ha a base classra mutat\u00f3 pointerre h\u00edvunk <code>delete</code> -t, akkor az a base class destruktor\u00e1t fogja megh\u00edvni. Ez probl\u00e9ma, ha a subclass destruktora valamilyen er\u0151forr\u00e1st szabad\u00edt fel, viszont nem h\u00edv\u00f3dik meg.</p> <p>Erre a probl\u00e9m\u00e1ra ny\u00fajtanak megold\u00e1st a virtu\u00e1lis destruktorok. Amikor egy base-re mutat\u00f3 pointerre <code>delete</code>-t h\u00edvunk, akkor a l\u00e1ncon felfel\u00e9(legals\u00f3 lesz\u00e1rmazott-&gt;legfels\u0151 lesz\u00e1rmazott) megh\u00edv\u00f3dik az \u00f6sszes destruktor.</p> <p> Futtasd!  <pre><code>struct base {\n    base() = default; //explicit default: \"im okay with what the compiler gives me\" (C++11 -t\u0151l)\n    virtual ~base() {\n        std::cout &lt;&lt; \"base dtor\\n\";\n    }\n};\n\nstruct derived : base {\n    derived() = default;\n    virtual ~derived() {\n        std::cout &lt;&lt; \"derived dtor\\n\";\n    }\n};\n\nint main(){\n    base* p = new derived;\n    delete p;\n}\n</code></pre></p> <p>Output: <pre><code>derived dtor\nbase dtor\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#final-keyword","title":"'final' keyword","text":"<p>A <code>final</code> keyword azt jelzi, hogy egy oszt\u00e1lyb\u00f3l m\u00e1r nem lehet lesz\u00e1rmazni.</p> <pre><code>struct something final {};\n\nstruct something_else : something {}; //error, 'something' is final\n</code></pre>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#virtual-inheritance","title":"Virtual inheritance","text":"<p>A gy\u00e9m\u00e1nt probl\u00e9ma az OOP egyik legnagyobb k\u00e9rd\u00e9se.  <pre><code>struct A {\n    int x;\n};\nstruct B : A {};\nstruct C : A {};\nstruct D : B, C {};\n</code></pre> Ekkor a lesz\u00e1rmaz\u00e1si gr\u00e1f egy \"gy\u00e9m\u00e1nt\" alakot alkot, amely a k\u00f6vetkez\u0151 probl\u00e9m\u00e1t veti fel:  Amikor a <code>D</code> -n kereszt\u00fcl <code>A</code> beli tagokat \u00e9r\u00fcnk el, akkor azt a <code>D</code> oszt\u00e1ly <code>B</code> vagy <code>C</code> r\u00e9sz\u00e9n tessz\u00fck -e meg? Ez akkora dilemma, hogy sok nyelv (pl. Java) szimpl\u00e1n nem enged egyszerre t\u00f6bb oszt\u00e1lyb\u00f3l val\u00f3 sz\u00e1rmaz\u00e1st.</p> <p>C++ -ban ezt a probl\u00e9m\u00e1t a virtu\u00e1lis lesz\u00e1rmaz\u00e1ssal oldott\u00e1k meg.</p> <p>Minden virtu\u00e1lisan \u00f6r\u00f6k\u00f6lt oszt\u00e1lyb\u00f3l garant\u00e1ltan csak egyet tartalmaz majd minden lesz\u00e1rmazott, akkor is, ha az oszt\u00e1ly t\u00f6bbsz\u00f6r is szerepel a hierarchi\u00e1ban.  A virtu\u00e1lis \u0151soszt\u00e1lyok minden nem-virtu\u00e1lis \u0151soszt\u00e1ly el\u0151tt j\u00f6nnek l\u00e9tre \u00e9s a virtu\u00e1lis base classok konstruktor\u00e1t csak a hierarchi\u00e1ban legals\u00f3 oszt\u00e1ly konstruktora fogja megh\u00edvni.</p> <p>B konstruktora h\u00edv\u00f3dik meg el\u0151sz\u00f6r, mivel virtual base class. Ez az <code>AA</code> initializer listj\u00e9nek sorrendj\u00e9t\u0151l f\u00fcggetlen, s\u0151t, warningot is kapunk, ha B nem legel\u0151l van. Ezut\u00e1n k\u00f6vetkezik <code>X</code> \u00e9s <code>Y</code> konstruktora, hiszen az <code>A</code> konstruktor t\u00f6rzse csak az initializer list ut\u00e1n, az objektum inicializ\u00e1l\u00e1sa ut\u00e1n fog lefutni.</p> <p>A destruktor h\u00edv\u00e1sok a konstruktor h\u00edv\u00e1sokkal ellent\u00e9tes sorrendben t\u00f6rt\u00e9nnek.</p> <p> Futtasd!  <pre><code>#include &lt;iostream&gt;\n\nstruct B\n{\n    int n;\n\n    B(int x) : n(x) {\n        std::cout &lt;&lt; \"b ctor\\n\";\n    }\n};\n\nstruct X : virtual B { \n    X() : B(1) {\n        std::cout &lt;&lt; \"x ctor\\n\";\n    } \n};\nstruct Y : virtual B {\n    Y() : B(2) {\n        std::cout &lt;&lt; \"y ctor\\n\";\n    }  \n};\nstruct AA : X, Y     {\n    AA() : B(3), X(), Y() {\n        std::cout &lt;&lt; \"a ctor\\n\";\n    } \n};\n\nint main(){\n    AA x;\n}\n</code></pre> A k\u00f3dr\u00e9szletben a konstruktor h\u00edv\u00e1sok sorrendje: * B konstruktor * X konstruktor * Y konstruktor * A konstruktor</p>"},{"location":"T%C3%B6rzsanyag/8-inheritance/#sajat-exception","title":"Saj\u00e1t exception","text":"<p>Kor\u00e1bban m\u00e1r szerepelt, hogy lehets\u00e9ges saj\u00e1t kiv\u00e9teleket l\u00e9trehozni. Ehhez semmi m\u00e1st nem kell csin\u00e1lni, mint az <code>std::exception</code>, vagy legt\u00f6bb esetben ink\u00e1bb az <code>std::runtime_error</code> oszt\u00e1lyb\u00f3l lesz\u00e1rmazni. A kiv\u00e9teleknek van egy konstruktora amely egy hiba\u00fczenetet vesz \u00e1t, ez\u00e9rt ezt implement\u00e1ljuk.</p> <p> Futtasd!  <pre><code>#include &lt;iostream&gt;\n#include &lt;stdexcept&gt;\n\nstruct image_load_error : std::runtime_error {\n    image_load_error(const std::string&amp; what) : std::runtime_error(what) {}\n};\n\nstruct image{\n    image(const std::string&amp; path){\n        if(path.empty()){\n            throw image_load_error(\"Image Load Error: image cannot have empty path!\");\n        }\n    }\n};\n\nint main(){\n    try{\n        image img(\"\");\n    }catch(const image_load_error&amp; img_error){\n        std::cout &lt;&lt; img_error.what();\n    }catch(const std::exception&amp; e){\n        std::cout &lt;&lt; e.what();\n    }\n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/9-sablonok/","title":"Sablonok (template)","text":"<p>Warning</p> <p>A sablon t\u00e9ma a jegyzetben \u00e1tdolgoz\u00e1s alatt \u00e1ll!</p>"},{"location":"T%C3%B6rzsanyag/9-sablonok/#sablon-alapok","title":"Sablon alapok","text":"<p>A C++ egyik legnagyobb el\u0151nye a C-vel szemben a generikus programoz\u00e1si lehet\u0151s\u00e9gekben rejlik. A jegyzetben m\u00e1r szerepelt az al\u00e1bbi f\u00fcggv\u00e9ny:</p> <p>https://godbolt.org/z/86ae5adTr <pre><code>//swap C++ -ban\nvoid cpp_swap(int&amp; x, int&amp; y){\n    int tmp = x;\n    x = y;\n    y = tmp;\n}\n</code></pre></p> <p>Ezt a f\u00fcggv\u00e9nyt szeretn\u00e9nk meg\u00edrni, hogy m\u0171k\u00f6dj\u00f6n mindenf\u00e9le t\u00edpusra. Term\u00e9szetesen ez C tud\u00e1ssal lehetetlen k\u00fcldet\u00e9snek t\u0171nhet,  azonban a C++ templatek f\u0151 felhaszn\u00e1l\u00e1si m\u00f3dja \u00e9ppen ez.</p> <p>https://godbolt.org/z/rrzMjYvK7 <pre><code>template &lt;typename T&gt; //sablondeklar\u00e1ci\u00f3, sablonparam\u00e9terek(itt T) felsorol\u00e1sa\nvoid cpp_swap(T&amp; x, T&amp;y){ //cpp_swap&lt;T&gt; f\u00fcggv\u00e9nysablon\n    T tmp = x;\n    x = y;\n    y = tmp;\n}\n</code></pre></p> <p>Figyelem!</p> <p>A template defin\u00edci\u00f3kat (explicit specializ\u00e1ci\u00f3kat kiv\u00e9ve) header fileokban kell meg\u00edrni! Ez vonatkozik a f\u00fcggv\u00e9nysablonokra \u00e9s oszt\u00e1lysablonokra is.</p> <p>A mi\u00e9rtj\u00e9r\u0151l az al\u00e1bbi (egy\u00e9bk\u00e9nt szint\u00e9n \u00e1ltalam \u00edrt) r\u00f6vid article-ben olvashattok: TCCPP Article</p> <p>A fent l\u00e1that\u00f3 <code>cpp_swap</code> -ot f\u00fcggv\u00e9nysablonnak h\u00edvjuk. \u00d6nmag\u00e1ban nem f\u00fcggv\u00e9ny, ahhoz \"p\u00e9ld\u00e1nyos\u00edtani\" kell. Ez a gyakorlatban annyit jelent, hogy haszn\u00e1ljuk.</p> <p>pl. <pre><code>int main(){\n    int x = 6;\n    int y = 2;\n\n    // cpp_swap&lt;T&gt; f\u00fcggv\u00e9nysablon p\u00e9ld\u00e1nyos\u00edt\u00e1sa T=int sablonparam\u00e9terekkel\n    cpp_swap&lt;int&gt;(x, y); //&lt;int&gt; &lt;- sablonparam\u00e9ter megad\u00e1sa\n\n    std::cout &lt;&lt; x &lt;&lt; ' ' &lt;&lt; y &lt;&lt; '\\n';\n\n    float a = 7.3;\n    float b = 1.2;\n    cpp_swap&lt;float&gt;(a, b);\n    std::cout &lt;&lt; a &lt;&lt; ' ' &lt;&lt; b;\n}\n</code></pre></p> <p>Amikor egy sablont p\u00e9ld\u00e1nyos\u00edtunk adott sablonparam\u00e9terekkel, olyankor val\u00f3j\u00e1ban ford\u00edt\u00e1sid\u0151ben k\u00f3d gener\u00e1l\u00f3dik az adott sablonparam\u00e9terek behelyettes\u00edt\u00e9s\u00e9vel. Pl. <pre><code>cpp_swap&lt;int&gt;(x, y); //cpp_swap&lt;T&gt; f\u00fcggv\u00e9nysablon p\u00e9ld\u00e1nyos\u00edt\u00e1sa T=int sablonparam\u00e9terekkel\n</code></pre> eset\u00e9n a <pre><code>void cpp_swap_int(int&amp; x, int&amp; y){ \n    int tmp = x;\n    x = y;\n    y = tmp;\n}\n</code></pre> k\u00f3d gener\u00e1l\u00f3dik. A <code>T</code> hely\u00e9re mindenhol <code>int</code> ker\u00fcl. Ezt a gener\u00e1lt k\u00f3dot nek\u00fck term\u00e9szetesen nem kell l\u00e1tnunk, vagy foglalkoznunk vele.</p> <p>Warning</p> <p>A f\u00fcggv\u00e9ny neve nem garant\u00e1ltan <code>cpp_swap_int</code> lesz, ennek a n\u00e9vnek eld\u00f6nt\u00e9se a ford\u00edt\u00f3 dolgam nek\u00fcnk ezzel nem kell foglalkozni, csak p\u00e9ldak\u00e9nt van itt.</p> <p>A sablonparam\u00e9tereket a ford\u00edt\u00f3 n\u00e9ha le tudja vezetni a kapott f\u00fcggv\u00e9nyparam\u00e9terekb\u0151l (template parameter deduction).</p> <p>P\u00e9ld\u00e1ul: <pre><code>double a = 5.2;\ndouble b = 1.2;\ncpp_swap(a, b); //nem kell megadni, hogy double t\u00edpus, mivel a \u00e9s b double t\u00edpus\u00faak\n\ncpp_swap&lt;double&gt;(a, x); //meg kell adni, hogy double t\u00edpus, mivel a \u00e9s x k\u00fcl\u00f6nb\u00f6z\u0151 t\u00edpus\u00faak, \u00edgy a ford\u00edt\u00f3 nem tud d\u00f6nteni\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/9-sablonok/#duck-typing","title":"Duck typing","text":"<p>A sablonokkal felmer\u00fcl egy \u00fajabb k\u00e9rd\u00e9s: milyen t\u00edpusokat fogadunk el? A v\u00e1lasz erre egyszer\u0171: mindent, amivel a f\u00fcggv\u00e9ny k\u00f3dja lefordul.</p> <p>Ezt \"duck typing\" -nak h\u00edvjuk: \"If it walks like a duck and it quacks like a duck, then it must be a duck\"</p> <p>P\u00e9ld\u00e1ul n\u00e9zz\u00fcnk meg egy f\u00fcggv\u00e9nyt, ami megmondja k\u00e9t valamir\u0151l, hogy az els\u0151 valami nagyobb-e, mint a m\u00e1sodik valami.</p> <pre><code>template&lt;typename T&gt;\nbool nagyobbe(T elso, T masodik){\n    return elso &gt; masodik;\n}\n</code></pre> <p>Milyen t\u00edpusokra m\u0171k\u00f6dik ez a f\u00fcggv\u00e9ny? H\u00e1t azokra, amelyek ezeket a felt\u00e9teleket teljes\u00edtik: * lem\u00e1solhat\u00f3k (hiszen m\u00e1solatk\u00e9nt vessz\u00fck \u00e1t \u0151ket) * \u00f6sszehasonl\u00edthat\u00f3k a <code>&gt;</code> oper\u00e1torral</p> <p>Vegy\u00fck \u00e9szre: ezek pontosan azok a felt\u00e9telek, amelyek ahhoz kellenek, hogy a k\u00f3dban az adott t\u00edpust T hely\u00e9re beillesztve a k\u00f3d leforduljon.</p> <p>Note</p> <p>Term\u00e9szetesen ezeken a felt\u00e9teleken laz\u00edthatn\u00e1nk, ha \u00e9rt\u00e9k helyett konstans referenciak\u00e9nt venn\u00e9nk \u00e1t a param\u00e9tereket.</p> <p>A sablonok korl\u00e1toz\u00e1s\u00e1ra l\u00e9teznek tov\u00e1bbi technik\u00e1k (SFINAE, concept), azonban ezek messze t\u00falmutatnak a t\u00e1rgy anyag\u00e1n.</p>"},{"location":"T%C3%B6rzsanyag/9-sablonok/#reszleges-specializacio","title":"R\u00e9szleges specializ\u00e1ci\u00f3","text":"<p>Tegy\u00fck fel, hogy szeretn\u00e9nk ha egy adott sablon egy speci\u00e1lis m\u00f3don m\u0171k\u00f6dj\u00f6n, ha egy adott t\u00edpust kap.  P\u00e9ld\u00e1ul ha a swap f\u00fcggv\u00e9ny\u00fcnk int-et kap, akkor \u00edrja ki, hogy \"int\", k\u00fcl\u00f6nben m\u0171k\u00f6dj\u00f6n norm\u00e1lis m\u00f3don.</p> <p>https://godbolt.org/z/zj1bfe5s9 <pre><code>template &lt;typename T&gt; \nvoid cpp_swap(T&amp; x, T&amp;y){ \n    T tmp = x;\n    x = y;\n    y = tmp;\n}\n\ntemplate &lt;&gt; \nvoid cpp_swap&lt;int&gt;(int&amp; x, int&amp;y){ //specializ\u00e1ci\u00f3 a T=int esetre\n    std::cout &lt;&lt; \"int \";\n    int tmp = x;\n    x = y;\n    y = tmp;\n}\n</code></pre></p>"},{"location":"T%C3%B6rzsanyag/9-sablonok/#osztalysablonok","title":"Oszt\u00e1lysablonok","text":"<p>Mint ahogyan a f\u00fcggv\u00e9nyekhez, az oszt\u00e1lyokhoz is lehet sablonokat k\u00e9sz\u00edtnei.  pl. <pre><code>template &lt;typename T&gt;\nclass Foo{\npublic:\n    T x;\n};\n</code></pre> Nagyon hasonl\u00f3an m\u0171k\u00f6dik a f\u00fcggv\u00e9nyparam\u00e9terekhez, szimpla k\u00f3dgener\u00e1l\u00e1sr\u00f3l van sz\u00f3.  Ugyn\u00fagy m\u0171k\u00f6dik vel\u00fck a specializ\u00e1ci\u00f3, valamint l\u00e9tezik a f\u00fcggv\u00e9nyekn\u00e9l ismert sablonparam\u00e9ter levezet\u00e9s is, ezt Class Template Argument Deduction (CTAD) -nek nevezik. </p> <p>Note</p> <p>A CTAD kicsit m\u00e1shogy m\u0171k\u00f6dik, mint az \u00e1ltal\u00e1nos, f\u00fcggv\u00e9nyekre vonatkoz\u00f3 TAD.  Akit \u00e9rdekel, annak aj\u00e1nlom Nina Ranns cppcon el\u0151ad\u00e1s\u00e1t a t\u00e9m\u00e1val kapcsolatban.</p>"},{"location":"T%C3%B6rzsanyag/9-sablonok/#dinamikus-tomb-atirasa-template-re","title":"Dinamikus t\u00f6mb \u00e1t\u00edr\u00e1sa template-re","text":"<p>Note</p> <p>Mivel az eg\u00e9sz t\u00f6mb egy oszt\u00e1lysablon lesz, \u00edgy ez az eg\u00e9sz header fileba fog ker\u00fclni.</p> <p>Igaz\u00e1b\u00f3l ez nem egy bonyolult folyamat. Mindenhol, ahol az <code>int</code> mint t\u00e1rolt t\u00edpus szerepel, ott lecser\u00e9lt\u00fck <code>T</code> -re.</p> <p>Note</p> <p>Az \u00faj verzi\u00f3ban <code>const T&amp;</code> -t vesz\u00fcnk \u00e1t beilleszt\u00e9sn\u00e9l. Eg\u00e9sz sz\u00e1mot olcs\u00f3 volt m\u00e1solni, de itt m\u00e1r nem ismerj\u00fck a t\u00edpust.</p> <pre><code>#include &lt;cstddef&gt; // std::size_t\n#include &lt;stdexcept&gt; // std::out_of_range\n#include &lt;iostream&gt; // std::cout\n\n\ntemplate&lt;typename T&gt;\nclass DinTomb{\n    T* tomb; //pointer a dinamikus t\u00f6mbre\n    std::size_t meret; //a dinamikus t\u00f6mb m\u00e9rete\n\npublic:\n    /**\n     * @brief Default konstruktor, mindent 0-ra inicializ\u00e1l\n     */\n    DinTomb() : tomb(nullptr), meret(0) {}\n\n    /**\n     * @brief hozz\u00e1ad egy \u00faj elemet a t\u00f6mb v\u00e9g\u00e9hez. Nagyon hasonl\u00edt a C-ben megismert algoritmushoz, csak malloc-free helyett new-delete[] van\n     * @param elem az elem amit hozz\u00e1adunk(lem\u00e1solhat\u00f3 kell, hogy legyen)\n     */\n    void push_back(const T&amp; elem) {\n        T* uj_tomb = new T[meret + 1];\n        for(std::size_t i = 0; i &lt; meret; ++i){\n            uj_tomb[i] = tomb[i];\n        }\n        uj_tomb[meret] = elem;\n        delete[] tomb; // delete[], mert t\u00f6mb\u00f6t szabad\u00edtunk fel.\n        tomb = uj_tomb;\n        ++meret;\n    }\n\n    std::size_t size() const { return meret; }\n\n    /**\n     * @brief indexel\u0151 f\u00fcggv\u00e9ny\n     * @param idx\n     * @return referencia az adott indexen l\u00e9v\u0151 elemre\n     * @throw std::out_of_range, ha t\u00falindexel\u00e9s t\u00f6rt\u00e9nik\n     */\n    T&amp; at(std::size_t idx) {\n        if(idx &gt;= meret) {\n            throw std::out_of_range(\"Tomb tulindexelve!\");\n        }\n        return tomb[idx];\n    }\n\n    //ua. mint az el\u0151bb, csak konstans verzi\u00f3\n    const T&amp; at(std::size_t idx) const { \n        if(idx &gt;= meret) {\n            throw std::out_of_range(\"Tomb tulindexelve!\");\n        }\n        return tomb[idx];\n    }\n\n    ~DinTomb() {\n        delete[] tomb; //destruktor felszabad\u00edtja a lefoglalt mem\u00f3ri\u00e1t\n    }\n};\n\nint main(){\n    DinTomb&lt;double&gt; tomb; // \u00edgy m\u00e1r megy double-ra is :D\n\n    tomb.push_back(4.2);\n    tomb.push_back(3.5);\n    tomb.at(0) = 5.1; \n    std::cout &lt;&lt; tomb.at(1);\n    return 0; \n}\n</code></pre>"},{"location":"T%C3%B6rzsanyag/9-sablonok/#nem-tipus-sablonparameterek","title":"Nem-t\u00edpus sablonparam\u00e9terek","text":"<p>Sablonparam\u00e9terk\u00e9nt \u00e1tadhat\u00f3 nem csak t\u00edpus, hanem gyakorlatilag b\u00e1rmilyen m\u00e1s objektum is. Pl. a standard library egy t\u00edpusa az <code>std::array</code>, amely els\u0151 f\u00fcggv\u00e9nyparam\u00e9tere a t\u00f6mbben t\u00e1rolt t\u00edpus, m\u00e1sodik f\u00fcggv\u00e9nyparam\u00e9tere egy pozit\u00edv eg\u00e9sz sz\u00e1m, a t\u00f6mb m\u00e9rete.</p> <pre><code>std::array&lt;int, 5&gt; tomb; //5 m\u00e9ret\u0171 int-eket t\u00e1rol\u00f3 t\u00f6mb\n</code></pre> <p>Ezt k\u00f3dban a k\u00f6vetkez\u0151k\u00e9nt \"replik\u00e1lhatjuk\": <pre><code>template&lt;typename T, std::size_t siz&gt;\nstruct array{ // array&lt;T, siz&gt; \"oszt\u00e1lysablon\"(oszt\u00e1lyok k\u00e9s\u0151bb)\n    T belso_tomb[siz];\n    //array implement\u00e1ci\u00f3...\n};\n\ntemplate &lt;int N&gt;\nvoid print_template_int(){\n    std::cout &lt;&lt; N &lt;&lt; '\\n';\n}\n</code></pre> Fontos azt megjegyezni, hogy a sablonok ford\u00edt\u00e1sid\u0151ben p\u00e9ldanyosodnak, sz\u00f3val minden sablonparam\u00e9ternek ford\u00edt\u00e1sid\u0151ben konstansnak kell lennie. pl. <pre><code>print_template_int&lt;5&gt;(); //ok\nint x = 5;\nprint_template_int&lt;x&gt;(); //hiba, x nem ford\u00edt\u00e1sidej\u0171 konstans(const int x sem oldan\u00e1 meg)\n</code></pre></p>"}]}